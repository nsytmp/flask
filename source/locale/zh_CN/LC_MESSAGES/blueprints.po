# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets Team
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Flask 1.1.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-06-20 10:49+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../blueprints.rst:4
msgid "Modular Applications with Blueprints"
msgstr "具有蓝图的模块化应用程序"

#: ../../blueprints.rst:10
msgid ""
"Flask uses a concept of *blueprints* for making application components "
"and supporting common patterns within an application or across "
"applications. Blueprints can greatly simplify how large applications work"
" and provide a central means for Flask extensions to register operations "
"on applications. A :class:`Blueprint` object works similarly to a "
":class:`Flask` application object, but it is not actually an application."
"  Rather it is a *blueprint* of how to construct or extend an "
"application."
msgstr ""

#: ../../blueprints.rst:19
msgid "Why Blueprints?"
msgstr "为何选择蓝图？"

#: ../../blueprints.rst:21
msgid "Blueprints in Flask are intended for these cases:"
msgstr "Flask中的蓝图适用于这些情况:"

#: ../../blueprints.rst:23
msgid ""
"Factor an application into a set of blueprints.  This is ideal for larger"
" applications; a project could instantiate an application object, "
"initialize several extensions, and register a collection of blueprints."
msgstr ""

#: ../../blueprints.rst:26
msgid ""
"Register a blueprint on an application at a URL prefix and/or subdomain. "
"Parameters in the URL prefix/subdomain become common view arguments (with"
" defaults) across all view functions in the blueprint."
msgstr ""

#: ../../blueprints.rst:29
msgid ""
"Register a blueprint multiple times on an application with different URL "
"rules."
msgstr "在具有不同URL规则的应用程序上多次注册蓝图. "

#: ../../blueprints.rst:31
msgid ""
"Provide template filters, static files, templates, and other utilities "
"through blueprints.  A blueprint does not have to implement applications "
"or view functions."
msgstr ""

#: ../../blueprints.rst:34
msgid ""
"Register a blueprint on an application for any of these cases when "
"initializing a Flask extension."
msgstr "在初始化Flask扩展时, 在应用程序中为任何这些情况注册蓝图. "

#: ../../blueprints.rst:37
msgid ""
"A blueprint in Flask is not a pluggable app because it is not actually an"
" application -- it's a set of operations which can be registered on an "
"application, even multiple times.  Why not have multiple application "
"objects?  You can do that (see :ref:`app-dispatch`), but your "
"applications will have separate configs and will be managed at the WSGI "
"layer."
msgstr ""

#: ../../blueprints.rst:43
msgid ""
"Blueprints instead provide separation at the Flask level, share "
"application config, and can change an application object as necessary "
"with being registered. The downside is that you cannot unregister a "
"blueprint once an application was created without having to destroy the "
"whole application object."
msgstr ""

#: ../../blueprints.rst:50
msgid "The Concept of Blueprints"
msgstr "蓝图的概念"

#: ../../blueprints.rst:52
msgid ""
"The basic concept of blueprints is that they record operations to execute"
" when registered on an application.  Flask associates view functions with"
" blueprints when dispatching requests and generating URLs from one "
"endpoint to another."
msgstr ""

#: ../../blueprints.rst:58
msgid "My First Blueprint"
msgstr "我的第一份蓝图"

#: ../../blueprints.rst:60
msgid ""
"This is what a very basic blueprint looks like.  In this case we want to "
"implement a blueprint that does simple rendering of static templates::"
msgstr "这是一个非常基本的蓝图. 在这种情况下, 我们希望实现一个简单渲染静态模板的蓝图::"

#: ../../blueprints.rst:77
msgid ""
"When you bind a function with the help of the ``@simple_page.route`` "
"decorator, the blueprint will record the intention of registering the "
"function ``show`` on the application when it's later registered. "
"Additionally it will prefix the endpoint of the function with the name of"
" the blueprint which was given to the :class:`Blueprint` constructor (in "
"this case also ``simple_page``). The blueprint's name does not modify the"
" URL, only the endpoint."
msgstr ""

#: ../../blueprints.rst:86
msgid "Registering Blueprints"
msgstr "注册蓝图"

#: ../../blueprints.rst:88
msgid "So how do you register that blueprint?  Like this::"
msgstr "那么你如何注册这个蓝图？像这样::"

#: ../../blueprints.rst:96
msgid ""
"If you check the rules registered on the application, you will find "
"these::"
msgstr "如果您检查在应用程序上注册的规则, 您将找到这些规则::"

#: ../../blueprints.rst:104
msgid ""
"The first one is obviously from the application itself for the static "
"files.  The other two are for the `show` function of the ``simple_page`` "
"blueprint.  As you can see, they are also prefixed with the name of the "
"blueprint and separated by a dot (``.``)."
msgstr ""

#: ../../blueprints.rst:109
msgid "Blueprints however can also be mounted at different locations::"
msgstr "然而, 蓝图也可以安装在不同的位置::"

#: ../../blueprints.rst:113
msgid "And sure enough, these are the generated rules::"
msgstr "当然, 这些是生成的规则::"

#: ../../blueprints.rst:120
msgid ""
"On top of that you can register blueprints multiple times though not "
"every blueprint might respond properly to that.  In fact it depends on "
"how the blueprint is implemented if it can be mounted more than once."
msgstr ""

#: ../../blueprints.rst:125
msgid "Blueprint Resources"
msgstr "蓝图资源"

#: ../../blueprints.rst:127
msgid ""
"Blueprints can provide resources as well.  Sometimes you might want to "
"introduce a blueprint only for the resources it provides."
msgstr "蓝图也可以提供资源. 有时您可能只想为其提供的资源引入蓝图. "

#: ../../blueprints.rst:131
msgid "Blueprint Resource Folder"
msgstr "蓝图资源文件夹"

#: ../../blueprints.rst:133
msgid ""
"Like for regular applications, blueprints are considered to be contained "
"in a folder.  While multiple blueprints can originate from the same "
"folder, it does not have to be the case and it's usually not recommended."
msgstr ""

#: ../../blueprints.rst:137
msgid ""
"The folder is inferred from the second argument to :class:`Blueprint` "
"which is usually `__name__`.  This argument specifies what logical Python"
" module or package corresponds to the blueprint.  If it points to an "
"actual Python package that package (which is a folder on the filesystem) "
"is the resource folder.  If it's a module, the package the module is "
"contained in will be the resource folder.  You can access the "
":attr:`Blueprint.root_path` property to see what the resource folder is::"
msgstr ""

#: ../../blueprints.rst:148
msgid ""
"To quickly open sources from this folder you can use the "
":meth:`~Blueprint.open_resource` function::"
msgstr "要从此文件夹快速打开源, 您可以使用:meth:`~Blueprint.open_resource`函数::"

#: ../../blueprints.rst:155
msgid "Static Files"
msgstr "静态文件"

#: ../../blueprints.rst:157
msgid ""
"A blueprint can expose a folder with static files by providing the path "
"to the folder on the filesystem with the ``static_folder`` argument. It "
"is either an absolute path or relative to the blueprint's location::"
msgstr ""

#: ../../blueprints.rst:163
msgid ""
"By default the rightmost part of the path is where it is exposed on the "
"web. This can be changed with the ``static_url_path`` argument. Because "
"the folder is called ``static`` here it will be available at the "
"``url_prefix`` of the blueprint + ``/static``. If the blueprint has the "
"prefix ``/admin``, the static URL will be ``/admin/static``."
msgstr ""

#: ../../blueprints.rst:169
msgid ""
"The endpoint is named ``blueprint_name.static``. You can generate URLs to"
" it with :func:`url_for` like you would with the static folder of the "
"application::"
msgstr ""

#: ../../blueprints.rst:175
msgid ""
"However, if the blueprint does not have a ``url_prefix``, it is not "
"possible to access the blueprint's static folder. This is because the URL"
" would be ``/static`` in this case, and the application's ``/static`` "
"route takes precedence. Unlike template folders, blueprint static folders"
" are not searched if the file does not exist in the application static "
"folder."
msgstr ""

#: ../../blueprints.rst:183
msgid "Templates"
msgstr "模板"

#: ../../blueprints.rst:185
msgid ""
"If you want the blueprint to expose templates you can do that by "
"providing the `template_folder` parameter to the :class:`Blueprint` "
"constructor::"
msgstr ""

#: ../../blueprints.rst:190
msgid ""
"For static files, the path can be absolute or relative to the blueprint "
"resource folder."
msgstr "对于静态文件, 路径可以是蓝图资源文件夹的绝对路径或相对路径. "

#: ../../blueprints.rst:193
msgid ""
"The template folder is added to the search path of templates but with a "
"lower priority than the actual application's template folder. That way "
"you can easily override templates that a blueprint provides in the actual"
" application. This also means that if you don't want a blueprint template"
" to be accidentally overridden, make sure that no other blueprint or "
"actual application template has the same relative path. When multiple "
"blueprints provide the same relative template path the first blueprint "
"registered takes precedence over the others."
msgstr ""

#: ../../blueprints.rst:202
msgid ""
"So if you have a blueprint in the folder ``yourapplication/admin`` and "
"you want to render the template ``'admin/index.html'`` and you have "
"provided ``templates`` as a `template_folder` you will have to create a "
"file like this: :file:`yourapplication/admin/templates/admin/index.html`."
" The reason for the extra ``admin`` folder is to avoid getting our "
"template overridden by a template named ``index.html`` in the actual "
"application template folder."
msgstr ""

#: ../../blueprints.rst:210
msgid ""
"To further reiterate this: if you have a blueprint named ``admin`` and "
"you want to render a template called :file:`index.html` which is specific"
" to this blueprint, the best idea is to lay out your templates like "
"this::"
msgstr ""

#: ../../blueprints.rst:222
msgid ""
"And then when you want to render the template, use "
":file:`admin/index.html` as the name to look up the template by.  If you "
"encounter problems loading the correct templates enable the "
"``EXPLAIN_TEMPLATE_LOADING`` config variable which will instruct Flask to"
" print out the steps it goes through to locate templates on every "
"``render_template`` call."
msgstr ""

#: ../../blueprints.rst:229
msgid "Building URLs"
msgstr "构建网址"

#: ../../blueprints.rst:231
msgid ""
"If you want to link from one page to another you can use the "
":func:`url_for` function just like you normally would do just that you "
"prefix the URL endpoint with the name of the blueprint and a dot "
"(``.``)::"
msgstr ""

#: ../../blueprints.rst:237
msgid ""
"Additionally if you are in a view function of a blueprint or a rendered "
"template and you want to link to another endpoint of the same blueprint, "
"you can use relative redirects by prefixing the endpoint with a dot "
"only::"
msgstr ""

#: ../../blueprints.rst:243
msgid ""
"This will link to ``admin.index`` for instance in case the current "
"request was dispatched to any other admin blueprint endpoint."
msgstr "这将链接到``admin.index``, 以防万一将当前请求分派到任何其他管理蓝图端点. "

#: ../../blueprints.rst:247
msgid "Error Handlers"
msgstr "错误处理程序"

#: ../../blueprints.rst:249
msgid ""
"Blueprints support the errorhandler decorator just like the "
":class:`Flask` application object, so it is easy to make Blueprint-"
"specific custom error pages."
msgstr ""

#: ../../blueprints.rst:253
msgid "Here is an example for a \"404 Page Not Found\" exception::"
msgstr "以下是“404找不到页面”例外的示例::"

#: ../../blueprints.rst:259
msgid ""
"Most errorhandlers will simply work as expected; however, there is a "
"caveat concerning handlers for 404 and 405 exceptions.  These "
"errorhandlers are only invoked from an appropriate ``raise`` statement or"
" a call to ``abort`` in another of the blueprint's view functions; they "
"are not invoked by, e.g., an invalid URL access.  This is because the "
"blueprint does not \"own\" a certain URL space, so the application "
"instance has no way of knowing which blueprint errorhandler it should run"
" if given an invalid URL.  If you would like to execute different "
"handling strategies for these errors based on URL prefixes, they may be "
"defined at the application level using the ``request`` proxy object::"
msgstr ""

#: ../../blueprints.rst:277
msgid "More information on error handling see :ref:`errorpages`."
msgstr "有关错误处理的更多信息, 请参阅:ref:`errorpages`. "

