# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets Team
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Flask 1.1.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-06-20 10:49+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../quickstart.rst:4
msgid "Quickstart"
msgstr "快速开始"

#: ../../quickstart.rst:6
msgid ""
"Eager to get started?  This page gives a good introduction to Flask.  It "
"assumes you already have Flask installed.  If you do not, head over to "
"the :ref:`installation` section."
msgstr "急于开始？这个页面给出了Flask的一个很好的介绍. 它假设您已经安装了Flask. 如果不这样做, 请转到 :ref:`installation` 部分. "

#: ../../quickstart.rst:12
msgid "A Minimal Application"
msgstr "最小的应用程序"

#: ../../quickstart.rst:14
msgid "A minimal Flask application looks something like this::"
msgstr "最小的Flask应用程序看起来像这样::"

#: ../../quickstart.rst:23
msgid "So what did that code do?"
msgstr "那个代码做了什么？"

#: ../../quickstart.rst:25
msgid ""
"First we imported the :class:`~flask.Flask` class.  An instance of this "
"class will be our WSGI application."
msgstr "首先我们导入了 :class:`~flask.Flask` 类. 这个类的一个实例将是我们的WSGI应用程序. "

#: ../../quickstart.rst:27
msgid ""
"Next we create an instance of this class. The first argument is the name "
"of the application's module or package.  If you are using a single module"
" (as in this example), you should use ``__name__`` because depending on "
"if it's started as application or imported as module the name will be "
"different (``'__main__'`` versus the actual import name). This is needed "
"so that Flask knows where to look for templates, static files, and so on."
" For more information have a look at the :class:`~flask.Flask` "
"documentation."
msgstr "接下来, 我们创建此类的实例. 第一个参数是应用程序模块或包的名称. 如果你使用单个模块(如本例所示), 你应该使用 ``__name__``, 因为它取决于它是作为应用程序启动还是作为模块导入, 名称将是不同的(``'__main __'`` 与实际进口名称). 这是必需的, 以便Flask知道在哪里查找模板, 静态文件等. 有关更多信息, 请查看 :class:`~flask.Flask` 文档. "

#: ../../quickstart.rst:34
msgid ""
"We then use the :meth:`~flask.Flask.route` decorator to tell Flask what "
"URL should trigger our function."
msgstr "然后我们使用 :meth:`~flask.Flask.route` 装饰器告诉Flask应该触发我们的函数的URL. "

#: ../../quickstart.rst:36
msgid ""
"The function is given a name which is also used to generate URLs for that"
" particular function, and returns the message we want to display in the "
"user's browser."
msgstr "该函数被赋予一个名称, 该名称也用于为该特定函数生成URL, 并返回我们想要在用户的浏览器中显示的消息. "

#: ../../quickstart.rst:40
msgid ""
"Just save it as :file:`hello.py` or something similar. Make sure to not "
"call your application :file:`flask.py` because this would conflict with "
"Flask itself."
msgstr "只需将其保存为 :file:`hello.py` 或类似的东西. 确保不要调用你的应用程序 :file:`flask.py` 因为这会与Flask本身发生冲突. "

#: ../../quickstart.rst:44
msgid ""
"To run the application you can either use the :command:`flask` command or"
" python's ``-m`` switch with Flask.  Before you can do that you need to "
"tell your terminal the application to work with by exporting the "
"``FLASK_APP`` environment variable::"
msgstr "要运行应用程序, 您可以使用 :command:`flask` 命令或python的 ``-m`` 开关与Flask. 在你能够做到这一点之前, 你需要通过导出 ``FLASK_APP`` 环境变量告诉你的终端应用程序::"

#: ../../quickstart.rst:53
msgid ""
"If you are on Windows, the environment variable syntax depends on command"
" line interpreter. On Command Prompt::"
msgstr "如果您使用的是Windows, 则环境变量语法取决于命令行解释程序. 在命令提示符上::"

#: ../../quickstart.rst:58
msgid "And on PowerShell::"
msgstr "在PowerShell上::"

#: ../../quickstart.rst:62
msgid "Alternatively you can use :command:`python -m flask`::"
msgstr "或者你可以使用 :command:`python -m flask`::"

#: ../../quickstart.rst:68
msgid ""
"This launches a very simple builtin server, which is good enough for "
"testing but probably not what you want to use in production. For "
"deployment options see :ref:`deployment`."
msgstr "这将启动一个非常简单的内置服务器, 它足以进行测试, 但可能不是您想要在生产中使用的内容. 有关部署选项, 请参阅 :ref:`deployment`. "

#: ../../quickstart.rst:72
msgid ""
"Now head over to `http://127.0.0.1:5000/ <http://127.0.0.1:5000/>`_, and "
"you should see your hello world greeting."
msgstr "现在转到 `http://127.0.0.1:5000/ <http://127.0.0.1:5000/>`_, 你应该看到你的世界问候. "

#: ../../quickstart.rst:77
msgid "Externally Visible Server"
msgstr "外部可见服务器"

#: ../../quickstart.rst:79
msgid ""
"If you run the server you will notice that the server is only accessible "
"from your own computer, not from any other in the network.  This is the "
"default because in debugging mode a user of the application can execute "
"arbitrary Python code on your computer."
msgstr "如果您运行服务器, 您会注意到服务器只能从您自己的计算机访问, 而不能从网络中的任何其他计算机访问. 这是默认设置, 因为在调试模式下, 应用程序的用户可以在您的计算机上执行任意Python代码. "

#: ../../quickstart.rst:84
msgid ""
"If you have the debugger disabled or trust the users on your network, you"
" can make the server publicly available simply by adding "
"``--host=0.0.0.0`` to the command line::"
msgstr "如果禁用调试器或信任网络上的用户, 只需在命令行中添加 ``--host = 0.0.0.0`` 即可公开服务器::"

#: ../../quickstart.rst:90
msgid "This tells your operating system to listen on all public IPs."
msgstr "这告诉您的操作系统要监听所有公共IP. "

#: ../../quickstart.rst:94
msgid "What to do if the Server does not Start"
msgstr "如果服务器未启动该怎么办"

#: ../../quickstart.rst:96
msgid ""
"In case the :command:`python -m flask` fails or :command:`flask` does not"
" exist, there are multiple reasons this might be the case.  First of all "
"you need to look at the error message."
msgstr "如果 :command:`python -m flask` 失败或 :command:`flask` 不存在, 可能有多种原因. 首先, 您需要查看错误消息. "

#: ../../quickstart.rst:101
msgid "Old Version of Flask"
msgstr "旧版 Flask"

#: ../../quickstart.rst:103
msgid ""
"Versions of Flask older than 0.11 use to have different ways to start the"
" application.  In short, the :command:`flask` command did not exist, and "
"neither did :command:`python -m flask`.  In that case you have two "
"options: either upgrade to newer Flask versions or have a look at the "
":ref:`server` docs to see the alternative method for running a server."
msgstr "早于0.11的Flask版本使用不同的方式来启动应用程序. 简而言之, :command:`flask` 命令不存在, 也没有 :command:`python -m flask`. 在这种情况下, 您有两个选择:升级到更新的Flask版本或查看 :ref:`server` 文档以查看运行服务器的替代方法. "

#: ../../quickstart.rst:110
msgid "Invalid Import Name"
msgstr "导入名称无效"

#: ../../quickstart.rst:112
msgid ""
"The ``FLASK_APP`` environment variable is the name of the module to "
"import at :command:`flask run`. In case that module is incorrectly named "
"you will get an import error upon start (or if debug is enabled when you "
"navigate to the application). It will tell you what it tried to import "
"and why it failed."
msgstr "``FLASK_APP`` 环境变量是要导入的模块的名称 :command:`flask run`. 如果模块命名错误, 您将在启动时收到导入错误(或者在导航到应用程序时启用调试). 它会告诉你它试图导入的内容以及它失败的原因. "

#: ../../quickstart.rst:117
msgid ""
"The most common reason is a typo or because you did not actually create "
"an ``app`` object."
msgstr "最常见的原因是拼写错误或因为你实际上没有创建一个 ``app`` 对象. "

#: ../../quickstart.rst:123
msgid "Debug Mode"
msgstr "调试模式"

#: ../../quickstart.rst:125
msgid "(Want to just log errors and stack traces? See :ref:`application-errors`)"
msgstr "(想只记录错误和堆栈跟踪？请参阅 :ref:`application-errors`)"

#: ../../quickstart.rst:127
msgid ""
"The :command:`flask` script is nice to start a local development server, "
"but you would have to restart it manually after each change to your code."
" That is not very nice and Flask can do better.  If you enable debug "
"support the server will reload itself on code changes, and it will also "
"provide you with a helpful debugger if things go wrong."
msgstr ":command:`flask` 脚本很适合启动本地开发服务器,  但每次更改代码后都必须手动重启. 这不是很好,  Flask可以做得更好. 如果启用调试支持,  服务器将在代码更改时重新加载,  如果出现问题,  它还将为您提供有用的调试器. "

#: ../../quickstart.rst:133
msgid ""
"To enable all development features (including debug mode) you can export "
"the ``FLASK_ENV`` environment variable and set it to ``development`` "
"before running the server::"
msgstr "要启用所有开发功能(包括调试模式), 您可以在运行服务器之前导出 ``FLASK_ENV`` 环境变量并将其设置为 ``development``::"

#: ../../quickstart.rst:140
msgid "(On Windows you need to use ``set`` instead of ``export``.)"
msgstr "(在Windows上, 你需要使用 ``set`` 而不是 ``export`` . )"

#: ../../quickstart.rst:142
msgid "This does the following things:"
msgstr "这做了以下事情:"

#: ../../quickstart.rst:144
msgid "it activates the debugger"
msgstr "它激活调试器"

#: ../../quickstart.rst:145
msgid "it activates the automatic reloader"
msgstr "它激活自动重新加载器"

#: ../../quickstart.rst:146
msgid "it enables the debug mode on the Flask application."
msgstr "它启用Flask应用程序上的调试模式. "

#: ../../quickstart.rst:148
msgid ""
"You can also control debug mode separately from the environment by "
"exporting ``FLASK_DEBUG=1``."
msgstr "您还可以通过导出 ``FLASK_DEBUG = 1`` 来独立于环境控制调试模式. "

#: ../../quickstart.rst:151
msgid "There are more parameters that are explained in the :ref:`server` docs."
msgstr "有更多参数在 :ref:`server` docs中解释. "

#: ../../quickstart.rst:153
msgid "Attention"
msgstr "注意"

#: ../../quickstart.rst:155
msgid ""
"Even though the interactive debugger does not work in forking "
"environments (which makes it nearly impossible to use on production "
"servers), it still allows the execution of arbitrary code. This makes it "
"a major security risk and therefore it **must never be used on production"
" machines**."
msgstr "即使交互式调试器在分叉环境中不起作用(这使得它几乎不可能在生产服务器上使用), 它仍然允许执行任意代码. 这使它成为一个主要的安全风险因此 **绝不能用于生产机器**. "

#: ../../quickstart.rst:160
msgid "Screenshot of the debugger in action:"
msgstr "正在运行的调试器的屏幕截图:"

#: ../../quickstart.rst:167
msgid ""
"More information on using the debugger can be found in the `Werkzeug "
"documentation`_."
msgstr "有关使用调试器的更多信息, 请参阅 `Werkzeug documentation`_ . "

#: ../../quickstart.rst:172
msgid "Have another debugger in mind? See :ref:`working-with-debuggers`."
msgstr "还有另一个调试器吗？看到 :ref:`working-with-debuggers`."

#: ../../quickstart.rst:176
msgid "Routing"
msgstr "路由"

#: ../../quickstart.rst:178
msgid ""
"Modern web applications use meaningful URLs to help users. Users are more"
" likely to like a page and come back if the page uses a meaningful URL "
"they can remember and use to directly visit a page."
msgstr "现代Web应用程序使用有意义的URL来帮助用户. 如果页面使用他们可以记住并用于直接访问页面的有意义的URL, 则用户更可能喜欢页面并返回. "

#: ../../quickstart.rst:182
msgid ""
"Use the :meth:`~flask.Flask.route` decorator to bind a function to a URL."
" ::"
msgstr "使用 :meth:`~flask.Flask.route` 装饰器将函数绑定到URL. ::"

#: ../../quickstart.rst:192
msgid ""
"You can do more! You can make parts of the URL dynamic and attach "
"multiple rules to a function."
msgstr "你可以做得更多！您可以将URL的一部分动态化并将多个规则附加到函数. "

#: ../../quickstart.rst:196
msgid "Variable Rules"
msgstr "变量规则"

#: ../../quickstart.rst:198
msgid ""
"You can add variable sections to a URL by marking sections with "
"``<variable_name>``. Your function then receives the ``<variable_name>`` "
"as a keyword argument. Optionally, you can use a converter to specify the"
" type of the argument like ``<converter:variable_name>``. ::"
msgstr "您可以通过使用 ``<variable_name>`` 标记节来向URL添加变量节. 然后, 您的函数接收 ``<variable_name>`` 作为关键字参数. 或者, 您可以使用转换器指定参数的类型, 如 ``<converter:variable_name>``. ::"

#: ../../quickstart.rst:218
msgid "Converter types:"
msgstr "转换器类型:"

#: ../../quickstart.rst:221
msgid "``string``"
msgstr "``string``"

#: ../../quickstart.rst:221
msgid "(default) accepts any text without a slash"
msgstr "(默认)接受任何没有斜线的文本"

#: ../../quickstart.rst:222
msgid "``int``"
msgstr "``int``"

#: ../../quickstart.rst:222
msgid "accepts positive integers"
msgstr "接受正整数"

#: ../../quickstart.rst:223
msgid "``float``"
msgstr "``float``"

#: ../../quickstart.rst:223
msgid "accepts positive floating point values"
msgstr "接受正浮点值"

#: ../../quickstart.rst:224
msgid "``path``"
msgstr "``path``"

#: ../../quickstart.rst:224
msgid "like ``string`` but also accepts slashes"
msgstr "喜欢 ``string`` 但也接受斜杠"

#: ../../quickstart.rst:225
msgid "``uuid``"
msgstr "``uuid``"

#: ../../quickstart.rst:225
msgid "accepts UUID strings"
msgstr "接受UUID字符串"

#: ../../quickstart.rst:229
msgid "Unique URLs / Redirection Behavior"
msgstr "唯一的URL/重定向行为"

#: ../../quickstart.rst:231
msgid "The following two rules differ in their use of a trailing slash. ::"
msgstr "以下两个规则在使用尾部斜杠时有所不同. ::"

#: ../../quickstart.rst:241
msgid ""
"The canonical URL for the ``projects`` endpoint has a trailing slash. "
"It's similar to a folder in a file system. If you access the URL without "
"a trailing slash, Flask redirects you to the canonical URL with the "
"trailing slash."
msgstr "``projects`` 端点的规范URL有一个尾部斜杠. 它类似于文件系统中的文件夹. 如果您访问的URL没有尾部斜杠, Flask会将您重定向到带有斜杠的规范URL. "

#: ../../quickstart.rst:246
msgid ""
"The canonical URL for the ``about`` endpoint does not have a trailing "
"slash. It's similar to the pathname of a file. Accessing the URL with a "
"trailing slash produces a 404 \"Not Found\" error. This helps keep URLs "
"unique for these resources, which helps search engines avoid indexing the"
" same page twice."
msgstr "``about`` 端点的规范URL没有尾部斜杠. 它类似于文件的路径名. 使用尾部斜杠访问URL会产生404 \"Not Found\" 错误. 这有助于保持URL对这些资源的唯一性, 这有助于搜索引擎避免两次索引同一页面. "

#: ../../quickstart.rst:256
msgid "URL Building"
msgstr "URL构建"

#: ../../quickstart.rst:258
msgid ""
"To build a URL to a specific function, use the :func:`~flask.url_for` "
"function. It accepts the name of the function as its first argument and "
"any number of keyword arguments, each corresponding to a variable part of"
" the URL rule. Unknown variable parts are appended to the URL as query "
"parameters."
msgstr "要构建特定函数的URL, 请使用 :func:`~flask.url_for` 函数. 它接受函数的名称作为其第一个参数和任意数量的关键字参数, 每个参数对应于URL规则的可变部分. 未知的变量部分作为查询参数附加到URL. "

#: ../../quickstart.rst:263
msgid ""
"Why would you want to build URLs using the URL reversing function "
":func:`~flask.url_for` instead of hard-coding them into your templates?"
msgstr "为什么要使用URL反转功能构建URL :func:`~flask.url_for` 而不是将它们硬编码到模板中？"

#: ../../quickstart.rst:266
msgid "Reversing is often more descriptive than hard-coding the URLs."
msgstr "反向通常比对URL进行硬编码更具描述性. "

#: ../../quickstart.rst:267
msgid ""
"You can change your URLs in one go instead of needing to remember to "
"manually change hard-coded URLs."
msgstr "您可以一次更改网址, 而无需记住手动更改硬编码网址. "

#: ../../quickstart.rst:269
msgid ""
"URL building handles escaping of special characters and Unicode data "
"transparently."
msgstr "URL构建可以透明地处理特殊字符和Unicode数据的转义. "

#: ../../quickstart.rst:271
msgid ""
"The generated paths are always absolute, avoiding unexpected behavior of "
"relative paths in browsers."
msgstr "生成的路径始终是绝对的, 从而避免了浏览器中相对路径的意外行为. "

#: ../../quickstart.rst:273
msgid ""
"If your application is placed outside the URL root, for example, in "
"``/myapplication`` instead of ``/``, :func:`~flask.url_for` properly "
"handles that for you."
msgstr "如果您的应用程序放在URL根目录之外, 例如, 在 ``/myapplication`` 而不是 ``/`` 中, :func:`~flask.url_for` 正确地为您处理. "

#: ../../quickstart.rst:277
msgid ""
"For example, here we use the :meth:`~flask.Flask.test_request_context` "
"method to try out :func:`~flask.url_for`. "
":meth:`~flask.Flask.test_request_context` tells Flask to behave as though"
" it's handling a request even while we use a Python shell. See :ref"
":`context-locals`."
msgstr "例如, 这里我们使用 :meth:`~flask.Flask.test_request_context` 方法来尝试 :func:`~flask.url_for`.   :meth:`~flask.Flask.test_request_context` 告诉Flask, 即使我们使用Python shell, 它也会像处理请求一样. 请参阅 :ref:`context-locals`. "

#: ../../quickstart.rst:315
msgid "HTTP Methods"
msgstr "HTTP方法"

#: ../../quickstart.rst:317
msgid ""
"Web applications use different HTTP methods when accessing URLs. You "
"should familiarize yourself with the HTTP methods as you work with Flask."
" By default, a route only answers to ``GET`` requests. You can use the "
"``methods`` argument of the :meth:`~flask.Flask.route` decorator to "
"handle different HTTP methods. ::"
msgstr "Web应用程序在访问URL时使用不同的HTTP方法. 在使用Flask时, 您应该熟悉HTTP方法. 默认情况下, 路由只回答 ``GET`` 请求. 你可以使用 :meth:`~flask.Flask.route` 装饰器的 ``methods`` 参数来处理不同的HTTP方法. ::"

#: ../../quickstart.rst:332
msgid ""
"If ``GET`` is present, Flask automatically adds support for the ``HEAD`` "
"method and handles ``HEAD`` requests according to the `HTTP RFC`_. "
"Likewise, ``OPTIONS`` is automatically implemented for you."
msgstr "如果存在 ``GET``, Flask会自动添加对 ``HEAD`` 方法的支持, 并根据 `HTTP RFC`_ 处理 ``HEAD`` 请求. 同样, ``OPTIONS`` 将自动为您实现. "

#: ../../quickstart.rst:339
msgid "Static Files"
msgstr "静态文件"

#: ../../quickstart.rst:341
msgid ""
"Dynamic web applications also need static files.  That's usually where "
"the CSS and JavaScript files are coming from.  Ideally your web server is"
" configured to serve them for you, but during development Flask can do "
"that as well.  Just create a folder called :file:`static` in your package"
" or next to your module and it will be available at ``/static`` on the "
"application."
msgstr "动态Web应用程序还需要静态文件. 这通常是CSS和JavaScript文件的来源. 理想情况下, 您的Web服务器已配置为为您提供服务, 但在开发期间, Flask也可以这样做. 只需在包中或模块旁创建一个名为 :file:`static` 的文件夹, 它就可以在应用程序的 ``/static`` 中找到. "

#: ../../quickstart.rst:347
msgid ""
"To generate URLs for static files, use the special ``'static'`` endpoint "
"name::"
msgstr "要为静态文件生成URL, 请使用特殊的 ``'static'`` 端点名称::"

#: ../../quickstart.rst:351
msgid "The file has to be stored on the filesystem as :file:`static/style.css`."
msgstr "该文件必须存储在文件系统中 :file:`static/style.css` . "

#: ../../quickstart.rst:354
msgid "Rendering Templates"
msgstr "渲染模板"

#: ../../quickstart.rst:356
msgid ""
"Generating HTML from within Python is not fun, and actually pretty "
"cumbersome because you have to do the HTML escaping on your own to keep "
"the application secure.  Because of that Flask configures the `Jinja2 "
"<http://jinja.pocoo.org/>`_ template engine for you automatically."
msgstr "从Python中生成HTML并不好玩, 实际上非常麻烦, 因为您必须自己进行HTML转义以保证应用程序的安全. 因为Flask会自动为您配置 `Jinja2 <http://jinja.pocoo.org/>`_ 模板引擎. "

#: ../../quickstart.rst:361
msgid ""
"To render a template you can use the :func:`~flask.render_template` "
"method.  All you have to do is provide the name of the template and the "
"variables you want to pass to the template engine as keyword arguments. "
"Here's a simple example of how to render a template::"
msgstr "要渲染模板, 可以使用 :func:`~flask.render_template` 方法. 您所要做的就是提供模板的名称以及要作为关键字参数传递给模板引擎的变量. 这是一个如何渲染模板的简单示例::"

#: ../../quickstart.rst:373
msgid ""
"Flask will look for templates in the :file:`templates` folder.  So if "
"your application is a module, this folder is next to that module, if it's"
" a package it's actually inside your package:"
msgstr "Flask将在 :file:`templates` 文件夹中查找模板. 因此, 如果您的应用程序是一个模块, 那么该文件夹就在该模块的旁边, 如果它是一个包, 它实际上在您的包中:"

#: ../../quickstart.rst:377
msgid "**Case 1**: a module::"
msgstr "**案例1**: 一个模块::"

#: ../../quickstart.rst:383
msgid "**Case 2**: a package::"
msgstr "**案例2**: 一个包::"

#: ../../quickstart.rst:390
msgid ""
"For templates you can use the full power of Jinja2 templates.  Head over "
"to the official `Jinja2 Template Documentation "
"<http://jinja.pocoo.org/docs/templates>`_ for more information."
msgstr "对于模板, 您可以使用Jinja2模板的全部功能. 请访问官方 `Jinja2模板文档 <http://jinja.pocoo.org/docs/templates>`_ 以获取更多信息. "

#: ../../quickstart.rst:394
msgid "Here is an example template:"
msgstr "这是一个示例模板:"

#: ../../quickstart.rst:406
msgid ""
"Inside templates you also have access to the :class:`~flask.request`, "
":class:`~flask.session` and :class:`~flask.g` [#]_ objects as well as the"
" :func:`~flask.get_flashed_messages` function."
msgstr "对于模板, 您可以使用Jinja2模板的全部功能. 有关更多信息, 请访问官方 `Jinja2模板文档 <http://jinja.pocoo.org/docs/templates>`_. "

#: ../../quickstart.rst:410
msgid ""
"Templates are especially useful if inheritance is used.  If you want to "
"know how that works, head over to the :ref:`template-inheritance` pattern"
" documentation.  Basically template inheritance makes it possible to keep"
" certain elements on each page (like header, navigation and footer)."
msgstr "如果使用继承, 模板特别有用. 如果你想知道它是如何工作的, 请转到 :ref:`template-inheritance` 模式文档. 基本上, 模板继承可以在每个页面上保留某些元素(如标题, 导航和页脚). "

#: ../../quickstart.rst:415
msgid ""
"Automatic escaping is enabled, so if ``name`` contains HTML it will be "
"escaped automatically.  If you can trust a variable and you know that it "
"will be safe HTML (for example because it came from a module that "
"converts wiki markup to HTML) you can mark it as safe by using the "
":class:`~jinja2.Markup` class or by using the ``|safe`` filter in the "
"template.  Head over to the Jinja 2 documentation for more examples."
msgstr "启用自动转义, 因此如果 ``name`` 包含HTML, 它将自动转义. 如果您可以信任变量并且您知道它将是安全的HTML(例如, 因为它来自将wiki标记转换为HTML的模块), 您可以使用 :class:`~jinja2.Markup` 类将其标记为安全或者在模板中使用 ``|safe`` 过滤器. 有关更多示例, 请访问Jinja 2文档. "

#: ../../quickstart.rst:422
msgid ""
"Here is a basic introduction to how the :class:`~jinja2.Markup` class "
"works::"
msgstr "以下是对 :class:`~jinja2.Markup` 类如何工作的基本介绍::"

#: ../../quickstart.rst:434
msgid ""
"Autoescaping is no longer enabled for all templates.  The following "
"extensions for templates trigger autoescaping: ``.html``, ``.htm``, "
"``.xml``, ``.xhtml``.  Templates loaded from a string will have "
"autoescaping disabled."
msgstr "不再为所有模板启用自动调整. 模板的以下扩展触发autoescaping:``.html``, ``.htm``, ``. xml``, ``.xhtml``. 从字符串加载的模板将禁用自动加载. "

#: ../../quickstart.rst:439
msgid ""
"Unsure what that :class:`~flask.g` object is? It's something in which you"
" can store information for your own needs, check the documentation of "
"that object (:class:`~flask.g`) and the :ref:`sqlite3` for more "
"information."
msgstr "不确定是什么 :class:`〜flask.g` 对象是？在这种情况下, 您可以根据自己的需要存储信息, 查看该对象的文档(:class:`〜flask.g`)和 :ref:`sqlite3` 以获取更多信息. "

#: ../../quickstart.rst:446
msgid "Accessing Request Data"
msgstr "访问请求数据"

#: ../../quickstart.rst:448
msgid ""
"For web applications it's crucial to react to the data a client sends to "
"the server.  In Flask this information is provided by the global "
":class:`~flask.request` object.  If you have some experience with Python "
"you might be wondering how that object can be global and how Flask "
"manages to still be threadsafe.  The answer is context locals:"
msgstr "对于Web应用程序, 对客户端发送到服务器的数据做出反应至关重要. 在Flask中, 此信息由global :class:`~flask.request` 对象提供. 如果您对Python有一些经验, 那么您可能想知道该对象如何是全局的以及Flask如何设置仍然是线程安全的. 答案是上下文本地人:"

#: ../../quickstart.rst:458
msgid "Context Locals"
msgstr "上下文本地"

#: ../../quickstart.rst:460
msgid "Insider Information"
msgstr "内幕消息"

#: ../../quickstart.rst:462
msgid ""
"If you want to understand how that works and how you can implement tests "
"with context locals, read this section, otherwise just skip it."
msgstr "如果您想了解它是如何工作的以及如何使用上下文本地实现测试, 请阅读本节, 否则只需跳过它. "

#: ../../quickstart.rst:465
msgid ""
"Certain objects in Flask are global objects, but not of the usual kind. "
"These objects are actually proxies to objects that are local to a "
"specific context.  What a mouthful.  But that is actually quite easy to "
"understand."
msgstr "Flask中的某些对象是全局对象, 但不是通常的对象. 这些对象实际上是特定上下文本地对象的代理. 多么满口. 但这实际上很容易理解. "

#: ../../quickstart.rst:469
msgid ""
"Imagine the context being the handling thread.  A request comes in and "
"the web server decides to spawn a new thread (or something else, the "
"underlying object is capable of dealing with concurrency systems other "
"than threads).  When Flask starts its internal request handling it "
"figures out that the current thread is the active context and binds the "
"current application and the WSGI environments to that context (thread). "
"It does that in an intelligent way so that one application can invoke "
"another application without breaking."
msgstr "想象一下上下文是处理线程. 请求进来, Web服务器决定生成一个新线程(或其他东西, 底层对象能够处理除线程以外的并发系统). 当Flask启动其内部请求处理时, 它会确定当前线程是活动上下文, 并将当前应用程序和WSGI环境绑定到该上下文(线程). 它以智能方式实现, 以便一个应用程序可以在不中断的情况下调用另一个应用程序. "

#: ../../quickstart.rst:478
msgid ""
"So what does this mean to you?  Basically you can completely ignore that "
"this is the case unless you are doing something like unit testing.  You "
"will notice that code which depends on a request object will suddenly "
"break because there is no request object.  The solution is creating a "
"request object yourself and binding it to the context.  The easiest "
"solution for unit testing is to use the "
":meth:`~flask.Flask.test_request_context` context manager.  In "
"combination with the ``with`` statement it will bind a test request so "
"that you can interact with it.  Here is an example::"
msgstr "那对你来说意味着什么？基本上你可以完全忽略这种情况, 除非你做的是单元测试. 您会注意到, 由于没有请求对象, 依赖于请求对象的代码会突然中断. 解决方案是自己创建一个请求对象并将其绑定到上下文. 单元测试最简单的解决方案是使用 :meth:`~flask.Flask.test_request_context` 上下文管理器. 结合 ``with`` 语句, 它将绑定一个测试请求, 以便您可以与它进行交互. 这是一个例子::"

#: ../../quickstart.rst:495
msgid ""
"The other possibility is passing a whole WSGI environment to the "
":meth:`~flask.Flask.request_context` method::"
msgstr "另一种可能性是将整个WSGI环境传递给 :meth:`~flask.Flask.request_context` 方法::"

#: ../../quickstart.rst:504
msgid "The Request Object"
msgstr "请求对象"

#: ../../quickstart.rst:506
msgid ""
"The request object is documented in the API section and we will not cover"
" it here in detail (see :class:`~flask.Request`). Here is a broad "
"overview of some of the most common operations.  First of all you have to"
" import it from the ``flask`` module::"
msgstr "请求对象记录在API部分中, 我们不会在这里详细介绍它(参见 :class:`~flask.Request`). 以下是一些最常见操作的概述. 首先, 你必须从 ``flask`` 模块导入它::"

#: ../../quickstart.rst:513
msgid ""
"The current request method is available by using the "
":attr:`~flask.Request.method` attribute.  To access form data (data "
"transmitted in a ``POST`` or ``PUT`` request) you can use the "
":attr:`~flask.Request.form` attribute.  Here is a full example of the two"
" attributes mentioned above::"
msgstr "当前的请求方法可以使用 :attr:`~flask.Request.method` 属性. 要访问表单数据(在 ``POST`` 或 ``PUT`` 请求中传输的数据), 您可以使用 :attr:`~faste.Request.form` 属性. 以下是上述两个属性的完整示例::"

#: ../../quickstart.rst:532
msgid ""
"What happens if the key does not exist in the ``form`` attribute?  In "
"that case a special :exc:`KeyError` is raised.  You can catch it like a "
"standard :exc:`KeyError` but if you don't do that, a HTTP 400 Bad Request"
" error page is shown instead.  So for many situations you don't have to "
"deal with that problem."
msgstr "如果 ``form`` 属性中不存在键, 会发生什么？在这种情况下, 会引发一个特殊的 :exc:`KeyError`. 您可以像标准一样捕获它 :exc:`KeyError` 但是如果不这样做, 则会显示HTTP 400 Bad Request错误页面. 因此, 对于许多情况, 您不必处理该问题. "

#: ../../quickstart.rst:538
msgid ""
"To access parameters submitted in the URL (``?key=value``) you can use "
"the :attr:`~flask.Request.args` attribute::"
msgstr "要访问URL中提交的参数(``?key=value``), 您可以使用 :attr:`~fars.Request.args` 属性::"

#: ../../quickstart.rst:543
msgid ""
"We recommend accessing URL parameters with `get` or by catching the "
":exc:`KeyError` because users might change the URL and presenting them a "
"400 bad request page in that case is not user friendly."
msgstr "我们建议使用 `get` 或通过捕获 :exc:`KeyError` 访问URL参数, 因为用户可能会更改URL并向其显示400个错误的请求页面, 在这种情况下用户不友好. "

#: ../../quickstart.rst:547
msgid ""
"For a full list of methods and attributes of the request object, head "
"over to the :class:`~flask.Request` documentation."
msgstr "有关请求对象的方法和属性的完整列表, 请转到 :class:`~flask.Request` 文档. "

#: ../../quickstart.rst:552
msgid "File Uploads"
msgstr "文件上传"

#: ../../quickstart.rst:554
msgid ""
"You can handle uploaded files with Flask easily.  Just make sure not to "
"forget to set the ``enctype=\"multipart/form-data\"`` attribute on your "
"HTML form, otherwise the browser will not transmit your files at all."
msgstr "您可以轻松地使用Flask处理上传的文件. 只要确保不要忘记在HTML表单上设置  ``enctype=\"multipart/form-data\"`` 属性, 否则浏览器根本不会传输你的文件. "

#: ../../quickstart.rst:558
msgid ""
"Uploaded files are stored in memory or at a temporary location on the "
"filesystem.  You can access those files by looking at the "
":attr:`~flask.request.files` attribute on the request object.  Each "
"uploaded file is stored in that dictionary.  It behaves just like a "
"standard Python :class:`file` object, but it also has a "
":meth:`~werkzeug.datastructures.FileStorage.save` method that allows you "
"to store that file on the filesystem of the server.  Here is a simple "
"example showing how that works::"
msgstr "上载的文件存储在内存中或文件系统上的临时位置. 您可以通过查看请求对象上的 :attr:`~flask.request.files` 属性来访问这些文件. 每个上传的文件都存储在该字典中. 它的行为就像一个标准的Python :class:`file` 对象, 但它也有一个 :meth:`~werkzeug.datastructures.FileStorage.save` 方法, 它允许你将该文件存储在服务器的文件系统上. 这是一个简单的例子, 说明它是如何工作的::"

#: ../../quickstart.rst:576
msgid ""
"If you want to know how the file was named on the client before it was "
"uploaded to your application, you can access the "
":attr:`~werkzeug.datastructures.FileStorage.filename` attribute.  However"
" please keep in mind that this value can be forged so never ever trust "
"that value.  If you want to use the filename of the client to store the "
"file on the server, pass it through the "
":func:`~werkzeug.utils.secure_filename` function that Werkzeug provides "
"for you::"
msgstr "如果要在将文件上载到应用程序之前了解文件在客户端上的命名方式, 可以访问 :attr:`~werkzeug.datastructures.FileStorage.filename` 属性. 但请记住, 这个价值可以伪造, 所以永远不要相信这个价值. 如果要使用客户端的文件名将文件存储在服务器上, 请通过Werkzeug为您提供的 :func:`~werkzeug.utils.secure_filename` 函数传递::"

#: ../../quickstart.rst:594
msgid "For some better examples, checkout the :ref:`uploading-files` pattern."
msgstr "有关更好的示例, 请查看 :ref:`uploaded-files` 模式. "

#: ../../quickstart.rst:597
msgid "Cookies"
msgstr "Cookies"

#: ../../quickstart.rst:599
msgid ""
"To access cookies you can use the :attr:`~flask.Request.cookies` "
"attribute.  To set cookies you can use the "
":attr:`~flask.Response.set_cookie` method of response objects.  The "
":attr:`~flask.Request.cookies` attribute of request objects is a "
"dictionary with all the cookies the client transmits.  If you want to use"
" sessions, do not use the cookies directly but instead use the "
":ref:`sessions` in Flask that add some security on top of cookies for "
"you."
msgstr "要访问cookie, 您可以使用 :attr:`~flask.Request.cookies` 属性. 要设置cookie, 您可以使用响应对象的 :attr:`~flask.Response.set_cookie` 方法. 请求对象的 :attr:`~flask.Request.cookies` 属性是一个包含客户端传输的所有cookie的字典. 如果你想使用会话, 不要直接使用cookie, 而是在Flask中使用 :ref:`sessions`, 为你添加一些基于cookie的安全性. "

#: ../../quickstart.rst:607
msgid "Reading cookies::"
msgstr "读饼干::"

#: ../../quickstart.rst:617
msgid "Storing cookies::"
msgstr "存储cookie::"

#: ../../quickstart.rst:627
msgid ""
"Note that cookies are set on response objects.  Since you normally just "
"return strings from the view functions Flask will convert them into "
"response objects for you.  If you explicitly want to do that you can use "
"the :meth:`~flask.make_response` function and then modify it."
msgstr "请注意, cookie是在响应对象上设置的. 由于您通常只是从视图函数返回字符串, Flask会将它们转换为响应对象. 如果您明确要这样做, 可以使用 :meth:`~flask.make_response` 函数然后修改它. "

#: ../../quickstart.rst:632
msgid ""
"Sometimes you might want to set a cookie at a point where the response "
"object does not exist yet.  This is possible by utilizing the :ref"
":`deferred-callbacks` pattern."
msgstr "有时您可能希望在响应对象尚不存在的位置设置cookie. 这可以通过使用 :ref:`deferred-callbacks` 模式来实现. "

#: ../../quickstart.rst:636
msgid "For this also see :ref:`about-responses`."
msgstr "为此, 请参阅 :ref:`about-responses`. "

#: ../../quickstart.rst:639
msgid "Redirects and Errors"
msgstr "重定向和错误"

#: ../../quickstart.rst:641
msgid ""
"To redirect a user to another endpoint, use the :func:`~flask.redirect` "
"function; to abort a request early with an error code, use the "
":func:`~flask.abort` function::"
msgstr "要将用户重定向到另一个端点, 请使用 :func:`~flask.redirect` 函数;要使用错误代码提前中止请求, 请使用 :func:`~flask.abort` 函数::"

#: ../../quickstart.rst:656
msgid ""
"This is a rather pointless example because a user will be redirected from"
" the index to a page they cannot access (401 means access denied) but it "
"shows how that works."
msgstr "这是一个相当无意义的例子, 因为用户将从索引重定向到他们无法访问的页面(401表示访问被拒绝), 但它显示了它的工作原理. "

#: ../../quickstart.rst:660
msgid ""
"By default a black and white error page is shown for each error code.  If"
" you want to customize the error page, you can use the "
":meth:`~flask.Flask.errorhandler` decorator::"
msgstr "默认情况下, 会为每个错误代码显示黑白错误页面. 如果要自定义错误页面, 可以使用 :meth:`~flask.Flask.errorhandler` 装饰器::"

#: ../../quickstart.rst:670
msgid ""
"Note the ``404`` after the :func:`~flask.render_template` call.  This "
"tells Flask that the status code of that page should be 404 which means "
"not found.  By default 200 is assumed which translates to: all went well."
msgstr "注意 :func:`~flask.render_template` 之后的 ``404``. 这告诉Flask该页面的状态代码应为404, 这意味着找不到. 默认情况下, 假定为200, 转换为: 一切顺利. "

#: ../../quickstart.rst:674
msgid "See :ref:`error-handlers` for more details."
msgstr "有关详细信息, 请参阅 :ref:`error-handlers` . "

#: ../../quickstart.rst:679
msgid "About Responses"
msgstr "关于回应"

#: ../../quickstart.rst:681
msgid ""
"The return value from a view function is automatically converted into a "
"response object for you.  If the return value is a string it's converted "
"into a response object with the string as response body, a ``200 OK`` "
"status code and a :mimetype:`text/html` mimetype.  The logic that Flask "
"applies to converting return values into response objects is as follows:"
msgstr "视图函数的返回值会自动转换为响应对象. 如果返回值是一个字符串, 它将转换为一个响应对象, 其中字符串作为响应体, 一个 ``200 OK`` 状态代码和一个 :mimetype:`text/html` mimetype. Flask应用于将返回值转换为响应对象的逻辑如下:"

#: ../../quickstart.rst:687
msgid ""
"If a response object of the correct type is returned it's directly "
"returned from the view."
msgstr "如果返回了正确类型的响应对象, 则直接从视图返回. "

#: ../../quickstart.rst:689
msgid ""
"If it's a string, a response object is created with that data and the "
"default parameters."
msgstr "如果是字符串, 则使用该数据和默认参数创建响应对象. "

#: ../../quickstart.rst:691
msgid ""
"If a tuple is returned the items in the tuple can provide extra "
"information.  Such tuples have to be in the form ``(response, status, "
"headers)`` or ``(response, headers)`` where at least one item has to be "
"in the tuple.  The ``status`` value will override the status code and "
"``headers`` can be a list or dictionary of additional header values."
msgstr "如果返回元组, 则元组中的项可以提供额外信息. 这样的元组必须采用 ``(response, status, headers)`` 或 ``(response, headers)`` 的形式, 其中至少有一个项必须在元组中. ``status`` 值将覆盖状态代码, ``headers`` 可以是附加标题值的列表或字典. "

#: ../../quickstart.rst:696
msgid ""
"If none of that works, Flask will assume the return value is a valid WSGI"
" application and convert that into a response object."
msgstr "如果这些都不起作用, Flask将假定返回值是一个有效的WSGI应用程序并将其转换为响应对象. "

#: ../../quickstart.rst:699
msgid ""
"If you want to get hold of the resulting response object inside the view "
"you can use the :func:`~flask.make_response` function."
msgstr "如果要在视图中获取生成的响应对象, 可以使用 :func:`~flask.make_response` 函数. "

#: ../../quickstart.rst:702
msgid "Imagine you have a view like this::"
msgstr "想象一下, 你有这样的观点::"

#: ../../quickstart.rst:708
msgid ""
"You just need to wrap the return expression with "
":func:`~flask.make_response` and get the response object to modify it, "
"then return it::"
msgstr "你只需要使用 :func:`~flask.make_response` 包装返回表达式并获取响应对象来修改它, 然后返回它::"

#: ../../quickstart.rst:721
msgid "Sessions"
msgstr "Sessions"

#: ../../quickstart.rst:723
msgid ""
"In addition to the request object there is also a second object called "
":class:`~flask.session` which allows you to store information specific to"
" a user from one request to the next.  This is implemented on top of "
"cookies for you and signs the cookies cryptographically.  What this means"
" is that the user could look at the contents of your cookie but not "
"modify it, unless they know the secret key used for signing."
msgstr "除了请求对象之外, 还有一个名为 :class:`~flask.session` 的第二个对象, 它允许您将特定于用户的信息从一个请求存储到下一个请求. 这是在cookie的基础上实现的, 并以加密方式对cookie进行签名. 这意味着用户可以查看cookie的内容但不能修改它, 除非他们知道用于签名的密钥. "

#: ../../quickstart.rst:730
msgid ""
"In order to use sessions you have to set a secret key.  Here is how "
"sessions work::"
msgstr "要使用会话, 您必须设置密钥. 以下是会议的工作方式::"

#: ../../quickstart.rst:764
msgid ""
"The :func:`~flask.escape` mentioned here does escaping for you if you are"
" not using the template engine (as in this example)."
msgstr "如果你没有使用模板引擎(如本例所示), 这里提到的 :func:`~flask.escape` 会为你逃避. "

#: ../../quickstart.rst:767
msgid "How to generate good secret keys"
msgstr "如何生成好的密钥"

#: ../../quickstart.rst:769
msgid ""
"A secret key should be as random as possible. Your operating system has "
"ways to generate pretty random data based on a cryptographic random "
"generator. Use the following command to quickly generate a value for "
":attr:`Flask.secret_key` (or :data:`SECRET_KEY`)::"
msgstr "密钥应尽可能随机. 您的操作系统可以基于加密随机生成器生成相当随机的数据. 使用以下命令快速生成以下值 :attr:`Flask.secret_key` (或 :data:`SECRET_KEY`)::"

#: ../../quickstart.rst:777
msgid ""
"A note on cookie-based sessions: Flask will take the values you put into "
"the session object and serialize them into a cookie.  If you are finding "
"some values do not persist across requests, cookies are indeed enabled, "
"and you are not getting a clear error message, check the size of the "
"cookie in your page responses compared to the size supported by web "
"browsers."
msgstr "关于基于cookie的会话的注释:Flask将获取您放入会话对象的值并将它们序列化为cookie. 如果您发现某些值不会在请求中保留, 则确实启用了Cookie, 并且您没有收到明确的错误消息, 请检查页面响应中的Cookie大小与Web浏览器支持的大小相比较. "

#: ../../quickstart.rst:783
msgid ""
"Besides the default client-side based sessions, if you want to handle "
"sessions on the server-side instead, there are several Flask extensions "
"that support this."
msgstr "除了默认的基于客户端的会话, 如果你想在服务器端处理会话, 有几个Flask扩展支持这个. "

#: ../../quickstart.rst:788
msgid "Message Flashing"
msgstr "消息闪烁"

#: ../../quickstart.rst:790
msgid ""
"Good applications and user interfaces are all about feedback.  If the "
"user does not get enough feedback they will probably end up hating the "
"application.  Flask provides a really simple way to give feedback to a "
"user with the flashing system.  The flashing system basically makes it "
"possible to record a message at the end of a request and access it on the"
" next (and only the next) request.  This is usually combined with a "
"layout template to expose the message."
msgstr "良好的应用程序和用户界面都是关于反馈的. 如果用户没有得到足够的反馈, 他们可能最终会厌恶应用程序.  Flask提供了一种使用闪烁系统向用户提供反馈的简单方法. 闪存系统基本上可以在请求结束时记录消息, 并在下一个(也就是下一个)请求中访问它. 这通常与布局模板结合使用以显示消息. "

#: ../../quickstart.rst:798
msgid ""
"To flash a message use the :func:`~flask.flash` method, to get hold of "
"the messages you can use :func:`~flask.get_flashed_messages` which is "
"also available in the templates.  Check out the :ref:`message-flashing-"
"pattern` for a full example."
msgstr "要刷新消息, 请使用 :func:`~flask.flash` 方法来获取可以使用的消息 :func:`~flask.get_flashed_messages`, 它也可以在模板中使用. 查看 :ref:`message-flashing-pattern` 获取完整示例. "

#: ../../quickstart.rst:804
msgid "Logging"
msgstr "记录"

#: ../../quickstart.rst:808
msgid ""
"Sometimes you might be in a situation where you deal with data that "
"should be correct, but actually is not.  For example you may have some "
"client-side code that sends an HTTP request to the server but it's "
"obviously malformed.  This might be caused by a user tampering with the "
"data, or the client code failing.  Most of the time it's okay to reply "
"with ``400 Bad Request`` in that situation, but sometimes that won't do "
"and the code has to continue working."
msgstr "有时您可能处理的数据应该是正确的, 但事实并非如此. 例如, 您可能有一些客户端代码向服务器发送HTTP请求, 但显然格式不正确. 这可能是由用户篡改数据或客户端代码失败引起的. 在大多数情况下, 在这种情况下可以用 ``400 Bad Request`` 回复, 但有时这样做不行, 代码必须继续工作. "

#: ../../quickstart.rst:816
msgid ""
"You may still want to log that something fishy happened.  This is where "
"loggers come in handy.  As of Flask 0.3 a logger is preconfigured for you"
" to use."
msgstr "您可能仍想记录发生了可疑的事情. 这是伐木工人派上用场的地方. 从Flask 0.3开始, 预先配置了一个记录器供您使用. "

#: ../../quickstart.rst:820
msgid "Here are some example log calls::"
msgstr "以下是一些示例日志调用::"

#: ../../quickstart.rst:826
msgid ""
"The attached :attr:`~flask.Flask.logger` is a standard logging "
":class:`~logging.Logger`, so head over to the official `logging "
"documentation <https://docs.python.org/library/logging.html>`_ for more "
"information."
msgstr "附 :attr:`~flask.Flask.logger` 是一个标准的日志记录:class:`~logging.Logger`, 所以转到官方的 `日志记录文档 <https://docs.python.org/library/logging .html>`_ 了解更多信息. "

#: ../../quickstart.rst:831
msgid "Read more on :ref:`application-errors`."
msgstr "阅读更多内容 :ref:`application-errors`."

#: ../../quickstart.rst:834
msgid "Hooking in WSGI Middlewares"
msgstr "挂钩WSGI中间件"

#: ../../quickstart.rst:836
msgid ""
"If you want to add a WSGI middleware to your application you can wrap the"
" internal WSGI application.  For example if you want to use one of the "
"middlewares from the Werkzeug package to work around bugs in lighttpd, "
"you can do it like this::"
msgstr "如果要将WSGI中间件添加到应用程序, 可以包装内部WSGI应用程序. 例如, 如果你想使用Werkzeug包中的一个中间件来处理lighttpd中的bug, 你可以这样做::"

#: ../../quickstart.rst:845
msgid "Using Flask Extensions"
msgstr "使用Flask扩展"

#: ../../quickstart.rst:847
msgid ""
"Extensions are packages that help you accomplish common tasks. For "
"example, Flask-SQLAlchemy provides SQLAlchemy support that makes it "
"simple and easy to use with Flask."
msgstr "扩展程序是帮助您完成常见任务的程序包. 例如, Flask-SQLAlchemy 提供 SQLAlchemy 支持, 使其易于与 Flask 一起使用. "

#: ../../quickstart.rst:851
msgid "For more on Flask extensions, have a look at :ref:`extensions`."
msgstr "有关Flask扩展的更多信息, 请查看 :ref:`extensions`. "

#: ../../quickstart.rst:854
msgid "Deploying to a Web Server"
msgstr "部署到Web服务器"

#: ../../quickstart.rst:856
msgid "Ready to deploy your new Flask app? Go to :ref:`deployment`."
msgstr "准备部署新的Flask应用了吗？转至 :ref:`deployment`. "

