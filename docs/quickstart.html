
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>快速开始 &#8212; Flask Documentation (1.1.x)</title>
    <link rel="stylesheet" href="_static/flask.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="shortcut icon" href="_static/flask-icon.png"/>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="教程" href="tutorial/index.html" />
    <link rel="prev" title="安装" href="installation.html" />
  <script>DOCUMENTATION_OPTIONS.URL_ROOT = './';</script>
   
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="tutorial/index.html" title="教程"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="installation.html" title="安装"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Flask Documentation (1.1.x)</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="quickstart">
<span id="id1"></span><h1>快速开始<a class="headerlink" href="#quickstart" title="永久链接至标题">¶</a></h1>
<p>急于开始？这个页面给出了Flask的一个很好的介绍。它假设您已经安装了Flask。如果不这样做，请转到 <a class="reference internal" href="installation.html#installation"><span class="std std-ref">安装</span></a> 部分。</p>
<div class="section" id="a-minimal-application">
<h2>最小的应用程序<a class="headerlink" href="#a-minimal-application" title="永久链接至标题">¶</a></h2>
<p>最小的Flask应用程序看起来像这样:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_world</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;Hello, World!&#39;</span>
</pre></div>
</div>
<p>那个代码做了什么？</p>
<ol class="arabic simple">
<li><p>首先我们导入了 <a class="reference internal" href="api.html#flask.Flask" title="flask.Flask"><code class="xref py py-class docutils literal notranslate"><span class="pre">Flask</span></code></a> 类. 这个类的一个实例将是我们的WSGI应用程序.</p></li>
<li><p>接下来, 我们创建此类的实例. 第一个参数是应用程序模块或包的名称. 如果你使用单个模块(如本例所示), 你应该使用 <code class="docutils literal notranslate"><span class="pre">__name__</span></code>, 因为它取决于它是作为应用程序启动还是作为模块导入, 名称将是不同的(<code class="docutils literal notranslate"><span class="pre">'__main</span> <span class="pre">__'</span></code> 与实际进口名称). 这是必需的, 以便Flask知道在哪里查找模板, 静态文件等. 有关更多信息, 请查看 <a class="reference internal" href="api.html#flask.Flask" title="flask.Flask"><code class="xref py py-class docutils literal notranslate"><span class="pre">Flask</span></code></a> 文档.</p></li>
<li><p>然后我们使用 <a class="reference internal" href="api.html#flask.Flask.route" title="flask.Flask.route"><code class="xref py py-meth docutils literal notranslate"><span class="pre">route()</span></code></a> 装饰器告诉Flask应该触发我们的函数的URL.</p></li>
<li><p>该函数被赋予一个名称, 该名称也用于为该特定函数生成URL, 并返回我们想要在用户的浏览器中显示的消息.</p></li>
</ol>
<p>只需将其保存为 <code class="file docutils literal notranslate"><span class="pre">hello.py</span></code> 或类似的东西. 确保不要调用你的应用程序 <code class="file docutils literal notranslate"><span class="pre">flask.py</span></code> 因为这会与Flask本身发生冲突.</p>
<p>要运行应用程序, 您可以使用 <strong class="command">flask</strong> 命令或python的 <code class="docutils literal notranslate"><span class="pre">-m</span></code> 开关与Flask. 在你能够做到这一点之前, 你需要通过导出 <code class="docutils literal notranslate"><span class="pre">FLASK_APP</span></code> 环境变量告诉你的终端应用程序:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ export FLASK_APP=hello.py
$ flask run
 * Running on http://127.0.0.1:5000/
</pre></div>
</div>
<p>如果您使用的是Windows, 则环境变量语法取决于命令行解释程序. 在命令提示符上:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="p">:</span>\<span class="n">path</span>\<span class="n">to</span>\<span class="n">app</span><span class="o">&gt;</span><span class="nb">set</span> <span class="n">FLASK_APP</span><span class="o">=</span><span class="n">hello</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>在PowerShell上:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>PS C:\path\to\app&gt; $env:FLASK_APP = &quot;hello.py&quot;
</pre></div>
</div>
<p>或者你可以使用 <strong class="command">python -m flask</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ export FLASK_APP=hello.py
$ python -m flask run
 * Running on http://127.0.0.1:5000/
</pre></div>
</div>
<p>这将启动一个非常简单的内置服务器, 它足以进行测试, 但可能不是您想要在生产中使用的内容. 有关部署选项, 请参阅 <a class="reference internal" href="deploying/index.html#deployment"><span class="std std-ref">部署选项</span></a>.</p>
<p>现在转到 <a class="reference external" href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a>, 你应该看到你的世界问候.</p>
<div class="admonition-externally-visible-server admonition">
<p class="admonition-title">外部可见服务器</p>
<p>如果您运行服务器, 您会注意到服务器只能从您自己的计算机访问, 而不能从网络中的任何其他计算机访问. 这是默认设置, 因为在调试模式下, 应用程序的用户可以在您的计算机上执行任意Python代码.</p>
<p>如果禁用调试器或信任网络上的用户, 只需在命令行中添加 <code class="docutils literal notranslate"><span class="pre">--host</span> <span class="pre">=</span> <span class="pre">0.0.0.0</span></code> 即可公开服务器:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ flask run --host=0.0.0.0
</pre></div>
</div>
<p>这告诉您的操作系统要监听所有公共IP.</p>
</div>
</div>
<div class="section" id="what-to-do-if-the-server-does-not-start">
<h2>如果服务器未启动该怎么办<a class="headerlink" href="#what-to-do-if-the-server-does-not-start" title="永久链接至标题">¶</a></h2>
<p>如果 <strong class="command">python -m flask</strong> 失败或 <strong class="command">flask</strong> 不存在, 可能有多种原因. 首先, 您需要查看错误消息.</p>
<div class="section" id="old-version-of-flask">
<h3>旧版 Flask<a class="headerlink" href="#old-version-of-flask" title="永久链接至标题">¶</a></h3>
<p>早于0.11的Flask版本使用不同的方式来启动应用程序. 简而言之, <strong class="command">flask</strong> 命令不存在, 也没有 <strong class="command">python -m flask</strong>. 在这种情况下, 您有两个选择:升级到更新的Flask版本或查看 <a class="reference internal" href="server.html#server"><span class="std std-ref">开发服务器</span></a> 文档以查看运行服务器的替代方法.</p>
</div>
<div class="section" id="invalid-import-name">
<h3>导入名称无效<a class="headerlink" href="#invalid-import-name" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">FLASK_APP</span></code> 环境变量是要导入的模块的名称 <strong class="command">flask run</strong>. 如果模块命名错误, 您将在启动时收到导入错误(或者在导航到应用程序时启用调试). 它会告诉你它试图导入的内容以及它失败的原因.</p>
<p>最常见的原因是拼写错误或因为你实际上没有创建一个 <code class="docutils literal notranslate"><span class="pre">app</span></code> 对象.</p>
</div>
</div>
<div class="section" id="debug-mode">
<span id="id2"></span><h2>调试模式<a class="headerlink" href="#debug-mode" title="永久链接至标题">¶</a></h2>
<p>(想只记录错误和堆栈跟踪？请参阅 <a class="reference internal" href="errorhandling.html#application-errors"><span class="std std-ref">应用程序错误</span></a>)</p>
<p><strong class="command">flask</strong> 脚本很适合启动本地开发服务器,  但每次更改代码后都必须手动重启. 这不是很好,  Flask可以做得更好. 如果启用调试支持,  服务器将在代码更改时重新加载,  如果出现问题,  它还将为您提供有用的调试器.</p>
<p>要启用所有开发功能（包括调试模式）, 您可以在运行服务器之前导出 <code class="docutils literal notranslate"><span class="pre">FLASK_ENV</span></code> 环境变量并将其设置为 <code class="docutils literal notranslate"><span class="pre">development</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ export FLASK_ENV=development
$ flask run
</pre></div>
</div>
<p>(在Windows上, 你需要使用 <code class="docutils literal notranslate"><span class="pre">set</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">export</span></code> . )</p>
<p>这做了以下事情:</p>
<ol class="arabic simple">
<li><p>它激活调试器</p></li>
<li><p>它激活自动重新加载器</p></li>
<li><p>它启用Flask应用程序上的调试模式.</p></li>
</ol>
<p>您还可以通过导出 <code class="docutils literal notranslate"><span class="pre">FLASK_DEBUG</span> <span class="pre">=</span> <span class="pre">1</span></code> 来独立于环境控制调试模式.</p>
<p>有更多参数在 <a class="reference internal" href="server.html#server"><span class="std std-ref">开发服务器</span></a> docs中解释.</p>
<div class="admonition-attention admonition">
<p class="admonition-title">注意</p>
<p>即使交互式调试器在分叉环境中不起作用(这使得它几乎不可能在生产服务器上使用), 它仍然允许执行任意代码. 这使它成为一个主要的安全风险因此 <strong>绝不能用于生产机器</strong>.</p>
</div>
<p>正在运行的调试器的屏幕截图:</p>
<img alt="screenshot of debugger in action" class="screenshot align-center" src="_images/debugger.png" />
<p>有关使用调试器的更多信息, 请参阅 <a class="reference external" href="http://werkzeug.pocoo.org/docs/debug/#using-the-debugger">Werkzeug documentation</a> .</p>
<p>还有另一个调试器吗？看到 <a class="reference internal" href="errorhandling.html#working-with-debuggers"><span class="std std-ref">Working with Debuggers</span></a>.</p>
</div>
<div class="section" id="routing">
<h2>路由<a class="headerlink" href="#routing" title="永久链接至标题">¶</a></h2>
<p>现代Web应用程序使用有意义的URL来帮助用户. 如果页面使用他们可以记住并用于直接访问页面的有意义的URL, 则用户更可能喜欢页面并返回.</p>
<p>使用 <a class="reference internal" href="api.html#flask.Flask.route" title="flask.Flask.route"><code class="xref py py-meth docutils literal notranslate"><span class="pre">route()</span></code></a> 装饰器将函数绑定到URL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;Index Page&#39;</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/hello&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;Hello, World&#39;</span>
</pre></div>
</div>
<p>你可以做得更多！您可以将URL的一部分动态化并将多个规则附加到函数.</p>
<div class="section" id="variable-rules">
<h3>变量规则<a class="headerlink" href="#variable-rules" title="永久链接至标题">¶</a></h3>
<p>您可以通过使用 <code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code> 标记节来向URL添加变量节. 然后, 您的函数接收 <code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code> 作为关键字参数. 或者, 您可以使用转换器指定参数的类型, 如 <code class="docutils literal notranslate"><span class="pre">&lt;converter:variable_name&gt;</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/user/&lt;username&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_user_profile</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="c1"># show the user profile for that user</span>
    <span class="k">return</span> <span class="s1">&#39;User </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">username</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/post/&lt;int:post_id&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_post</span><span class="p">(</span><span class="n">post_id</span><span class="p">):</span>
    <span class="c1"># show the post with the given id, the id is an integer</span>
    <span class="k">return</span> <span class="s1">&#39;Post </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">post_id</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/path/&lt;path:subpath&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_subpath</span><span class="p">(</span><span class="n">subpath</span><span class="p">):</span>
    <span class="c1"># show the subpath after /path/</span>
    <span class="k">return</span> <span class="s1">&#39;Subpath </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">subpath</span>
</pre></div>
</div>
<p>转换器类型:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">string</span></code></p></td>
<td><p>(默认)接受任何没有斜线的文本</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>接受正整数</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>接受正浮点值</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">path</span></code></p></td>
<td><p>喜欢 <code class="docutils literal notranslate"><span class="pre">string</span></code> 但也接受斜杠</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">uuid</span></code></p></td>
<td><p>接受UUID字符串</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="unique-urls-redirection-behavior">
<h3>唯一的URL/重定向行为<a class="headerlink" href="#unique-urls-redirection-behavior" title="永久链接至标题">¶</a></h3>
<p>以下两个规则在使用尾部斜杠时有所不同.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/projects/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">projects</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;The project page&#39;</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/about&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">about</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;The about page&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">projects</span></code> 端点的规范URL有一个尾部斜杠. 它类似于文件系统中的文件夹. 如果您访问的URL没有尾部斜杠, Flask会将您重定向到带有斜杠的规范URL.</p>
<p><code class="docutils literal notranslate"><span class="pre">about</span></code> 端点的规范URL没有尾部斜杠. 它类似于文件的路径名. 使用尾部斜杠访问URL会产生404 “Not Found” 错误. 这有助于保持URL对这些资源的唯一性, 这有助于搜索引擎避免两次索引同一页面.</p>
</div>
<div class="section" id="url-building">
<span id="id3"></span><h3>URL构建<a class="headerlink" href="#url-building" title="永久链接至标题">¶</a></h3>
<p>要构建特定函数的URL, 请使用 <a class="reference internal" href="api.html#flask.url_for" title="flask.url_for"><code class="xref py py-func docutils literal notranslate"><span class="pre">url_for()</span></code></a> 函数. 它接受函数的名称作为其第一个参数和任意数量的关键字参数, 每个参数对应于URL规则的可变部分. 未知的变量部分作为查询参数附加到URL.</p>
<p>为什么要使用URL反转功能构建URL <a class="reference internal" href="api.html#flask.url_for" title="flask.url_for"><code class="xref py py-func docutils literal notranslate"><span class="pre">url_for()</span></code></a> 而不是将它们硬编码到模板中？</p>
<ol class="arabic simple">
<li><p>反向通常比对URL进行硬编码更具描述性.</p></li>
<li><p>您可以一次更改网址, 而无需记住手动更改硬编码网址.</p></li>
<li><p>URL构建可以透明地处理特殊字符和Unicode数据的转义.</p></li>
<li><p>生成的路径始终是绝对的, 从而避免了浏览器中相对路径的意外行为.</p></li>
<li><p>如果您的应用程序放在URL根目录之外, 例如, 在 <code class="docutils literal notranslate"><span class="pre">/myapplication</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">/</span></code> 中, <a class="reference internal" href="api.html#flask.url_for" title="flask.url_for"><code class="xref py py-func docutils literal notranslate"><span class="pre">url_for()</span></code></a> 正确地为您处理.</p></li>
</ol>
<p>例如, 这里我们使用 <a class="reference internal" href="api.html#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><code class="xref py py-meth docutils literal notranslate"><span class="pre">test_request_context()</span></code></a> 方法来尝试 <a class="reference internal" href="api.html#flask.url_for" title="flask.url_for"><code class="xref py py-func docutils literal notranslate"><span class="pre">url_for()</span></code></a>.   <a class="reference internal" href="api.html#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><code class="xref py py-meth docutils literal notranslate"><span class="pre">test_request_context()</span></code></a> 告诉Flask, 即使我们使用Python shell, 它也会像处理请求一样. 请参阅 <a class="reference internal" href="#context-locals"><span class="std std-ref">上下文本地</span></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">url_for</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;index&#39;</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;login&#39;</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/user/&lt;username&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;{}</span><span class="se">\&#39;</span><span class="s1">s profile&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">username</span><span class="p">)</span>

<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;login&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;login&#39;</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;profile&#39;</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="s1">&#39;John Doe&#39;</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>/
/login
/login?next=/
/user/John%20Doe
</pre></div>
</div>
</div>
<div class="section" id="http-methods">
<h3>HTTP方法<a class="headerlink" href="#http-methods" title="永久链接至标题">¶</a></h3>
<p>Web应用程序在访问URL时使用不同的HTTP方法. 在使用Flask时, 您应该熟悉HTTP方法. 默认情况下, 路由只回答 <code class="docutils literal notranslate"><span class="pre">GET</span></code> 请求. 你可以使用 <a class="reference internal" href="api.html#flask.Flask.route" title="flask.Flask.route"><code class="xref py py-meth docutils literal notranslate"><span class="pre">route()</span></code></a> 装饰器的 <code class="docutils literal notranslate"><span class="pre">methods</span></code> 参数来处理不同的HTTP方法.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">do_the_login</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">show_the_login_form</span><span class="p">()</span>
</pre></div>
</div>
<p>如果存在 <code class="docutils literal notranslate"><span class="pre">GET</span></code>, Flask会自动添加对 <code class="docutils literal notranslate"><span class="pre">HEAD</span></code> 方法的支持, 并根据 <a class="reference external" href="https://www.ietf.org/rfc/rfc2068.txt">HTTP RFC</a> 处理 <code class="docutils literal notranslate"><span class="pre">HEAD</span></code> 请求. 同样, <code class="docutils literal notranslate"><span class="pre">OPTIONS</span></code> 将自动为您实现.</p>
</div>
</div>
<div class="section" id="static-files">
<h2>静态文件<a class="headerlink" href="#static-files" title="永久链接至标题">¶</a></h2>
<p>动态Web应用程序还需要静态文件. 这通常是CSS和JavaScript文件的来源. 理想情况下, 您的Web服务器已配置为为您提供服务, 但在开发期间, Flask也可以这样做. 只需在包中或模块旁创建一个名为 <code class="file docutils literal notranslate"><span class="pre">static</span></code> 的文件夹, 它就可以在应用程序的 <code class="docutils literal notranslate"><span class="pre">/static</span></code> 中找到.</p>
<p>要为静态文件生成URL, 请使用特殊的 <code class="docutils literal notranslate"><span class="pre">'static'</span></code> 端点名称:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;static&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;style.css&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>该文件必须存储在文件系统中 <code class="file docutils literal notranslate"><span class="pre">static/style.css</span></code> .</p>
</div>
<div class="section" id="rendering-templates">
<h2>渲染模板<a class="headerlink" href="#rendering-templates" title="永久链接至标题">¶</a></h2>
<p>从Python中生成HTML并不好玩, 实际上非常麻烦, 因为您必须自己进行HTML转义以保证应用程序的安全. 因为Flask会自动为您配置 <a class="reference external" href="http://jinja.pocoo.org/">Jinja2</a> 模板引擎.</p>
<p>要渲染模板, 可以使用 <a class="reference internal" href="api.html#flask.render_template" title="flask.render_template"><code class="xref py py-func docutils literal notranslate"><span class="pre">render_template()</span></code></a> 方法. 您所要做的就是提供模板的名称以及要作为关键字参数传递给模板引擎的变量. 这是一个如何渲染模板的简单示例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">render_template</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/hello/&#39;</span><span class="p">)</span>
<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/hello/&lt;name&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;hello.html&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>Flask将在 <code class="file docutils literal notranslate"><span class="pre">templates</span></code> 文件夹中查找模板. 因此, 如果您的应用程序是一个模块, 那么该文件夹就在该模块的旁边, 如果它是一个包, 它实际上在您的包中:</p>
<p><strong>案例1</strong>: 一个模块:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">application</span><span class="o">.</span><span class="n">py</span>
<span class="o">/</span><span class="n">templates</span>
    <span class="o">/</span><span class="n">hello</span><span class="o">.</span><span class="n">html</span>
</pre></div>
</div>
<p><strong>案例2</strong>: 一个包:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">application</span>
    <span class="o">/</span><span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="o">/</span><span class="n">templates</span>
        <span class="o">/</span><span class="n">hello</span><span class="o">.</span><span class="n">html</span>
</pre></div>
</div>
<p>对于模板, 您可以使用Jinja2模板的全部功能. 请访问官方 <a class="reference external" href="http://jinja.pocoo.org/docs/templates">Jinja2模板文档</a> 以获取更多信息.</p>
<p>这是一个示例模板:</p>
<div class="highlight-html+jinja notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;!doctype html&gt;</span>
<span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Hello from Flask<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="cp">{%</span> <span class="k">if</span> <span class="nv">name</span> <span class="cp">%}</span>
  <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Hello <span class="cp">{{</span> <span class="nv">name</span> <span class="cp">}}</span>!<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="cp">{%</span> <span class="k">else</span> <span class="cp">%}</span>
  <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Hello, World!<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span>
</pre></div>
</div>
<p>对于模板, 您可以使用Jinja2模板的全部功能. 有关更多信息, 请访问官方 <a class="reference external" href="http://jinja.pocoo.org/docs/templates">Jinja2模板文档</a>.</p>
<p>如果使用继承, 模板特别有用. 如果你想知道它是如何工作的, 请转到 <a class="reference internal" href="patterns/templateinheritance.html#template-inheritance"><span class="std std-ref">模板继承</span></a> 模式文档. 基本上, 模板继承可以在每个页面上保留某些元素(如标题, 导航和页脚).</p>
<p>启用自动转义, 因此如果 <code class="docutils literal notranslate"><span class="pre">name</span></code> 包含HTML, 它将自动转义. 如果您可以信任变量并且您知道它将是安全的HTML(例如, 因为它来自将wiki标记转换为HTML的模块), 您可以使用 <a class="reference external" href="http://jinja.pocoo.org/docs/api/#jinja2.Markup" title="(在 Jinja2 v2.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Markup</span></code></a> 类将其标记为安全或者在模板中使用 <code class="docutils literal notranslate"><span class="pre">|safe</span></code> 过滤器. 有关更多示例, 请访问Jinja 2文档.</p>
<p>以下是对 <a class="reference external" href="http://jinja.pocoo.org/docs/api/#jinja2.Markup" title="(在 Jinja2 v2.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Markup</span></code></a> 类如何工作的基本介绍:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">Markup</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s1">&#39;&lt;strong&gt;Hello </span><span class="si">%s</span><span class="s1">!&lt;/strong&gt;&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="s1">&#39;&lt;blink&gt;hacker&lt;/blink&gt;&#39;</span>
<span class="go">Markup(u&#39;&lt;strong&gt;Hello &amp;lt;blink&amp;gt;hacker&amp;lt;/blink&amp;gt;!&lt;/strong&gt;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;&lt;blink&gt;hacker&lt;/blink&gt;&#39;</span><span class="p">)</span>
<span class="go">Markup(u&#39;&amp;lt;blink&amp;gt;hacker&amp;lt;/blink&amp;gt;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s1">&#39;&lt;em&gt;Marked up&lt;/em&gt; &amp;raquo; HTML&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">striptags</span><span class="p">()</span>
<span class="go">u&#39;Marked up \xbb HTML&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 0.5 版更改: </span>不再为所有模板启用自动调整. 模板的以下扩展触发autoescaping:<code class="docutils literal notranslate"><span class="pre">.html</span></code>, <code class="docutils literal notranslate"><span class="pre">.htm</span></code>, <code class="docutils literal notranslate"><span class="pre">.</span> <span class="pre">xml</span></code>, <code class="docutils literal notranslate"><span class="pre">.xhtml</span></code>. 从字符串加载的模板将禁用自动加载.</p>
</div>
<details class="changelog">
<summary>Changelog</summary></details><dl class="footnote brackets">
<dt class="label" id="id5"><span class="brackets"><a class="fn-backref" href="#id4">1</a></span></dt>
<dd><p>不确定是什么 <code class="xref py py-class docutils literal notranslate"><span class="pre">〜flask.g</span></code> 对象是？在这种情况下, 您可以根据自己的需要存储信息, 查看该对象的文档(<code class="xref py py-class docutils literal notranslate"><span class="pre">〜flask.g</span></code>)和 <a class="reference internal" href="patterns/sqlite3.html#sqlite3"><span class="std std-ref">在Flask中使用SQLite 3</span></a> 以获取更多信息.</p>
</dd>
</dl>
</div>
<div class="section" id="accessing-request-data">
<h2>访问请求数据<a class="headerlink" href="#accessing-request-data" title="永久链接至标题">¶</a></h2>
<p>对于Web应用程序, 对客户端发送到服务器的数据做出反应至关重要. 在Flask中, 此信息由global <a class="reference internal" href="api.html#flask.request" title="flask.request"><code class="xref py py-class docutils literal notranslate"><span class="pre">request</span></code></a> 对象提供. 如果您对Python有一些经验, 那么您可能想知道该对象如何是全局的以及Flask如何设置仍然是线程安全的. 答案是上下文本地人:</p>
<div class="section" id="context-locals">
<span id="id6"></span><h3>上下文本地<a class="headerlink" href="#context-locals" title="永久链接至标题">¶</a></h3>
<div class="admonition-insider-information admonition">
<p class="admonition-title">内幕消息</p>
<p>如果您想了解它是如何工作的以及如何使用上下文本地实现测试, 请阅读本节, 否则只需跳过它.</p>
</div>
<p>Flask中的某些对象是全局对象, 但不是通常的对象. 这些对象实际上是特定上下文本地对象的代理. 多么满口. 但这实际上很容易理解.</p>
<p>想象一下上下文是处理线程. 请求进来, Web服务器决定生成一个新线程(或其他东西, 底层对象能够处理除线程以外的并发系统). 当Flask启动其内部请求处理时, 它会确定当前线程是活动上下文, 并将当前应用程序和WSGI环境绑定到该上下文(线程). 它以智能方式实现, 以便一个应用程序可以在不中断的情况下调用另一个应用程序.</p>
<p>那对你来说意味着什么？基本上你可以完全忽略这种情况, 除非你做的是单元测试. 您会注意到, 由于没有请求对象, 依赖于请求对象的代码会突然中断. 解决方案是自己创建一个请求对象并将其绑定到上下文. 单元测试最简单的解决方案是使用 <a class="reference internal" href="api.html#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><code class="xref py py-meth docutils literal notranslate"><span class="pre">test_request_context()</span></code></a> 上下文管理器. 结合 <code class="docutils literal notranslate"><span class="pre">with</span></code> 语句, 它将绑定一个测试请求, 以便您可以与它进行交互. 这是一个例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>

<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">(</span><span class="s1">&#39;/hello&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;POST&#39;</span><span class="p">):</span>
    <span class="c1"># now you can do something with the request until the</span>
    <span class="c1"># end of the with block, such as basic assertions:</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">path</span> <span class="o">==</span> <span class="s1">&#39;/hello&#39;</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span>
</pre></div>
</div>
<p>另一种可能性是将整个WSGI环境传递给 <a class="reference internal" href="api.html#flask.Flask.request_context" title="flask.Flask.request_context"><code class="xref py py-meth docutils literal notranslate"><span class="pre">request_context()</span></code></a> 方法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>

<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="the-request-object">
<h3>请求对象<a class="headerlink" href="#the-request-object" title="永久链接至标题">¶</a></h3>
<p>请求对象记录在API部分中, 我们不会在这里详细介绍它(参见 <a class="reference internal" href="api.html#flask.Request" title="flask.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>). 以下是一些最常见操作的概述. 首先, 你必须从 <code class="docutils literal notranslate"><span class="pre">flask</span></code> 模块导入它:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>
</pre></div>
</div>
<p>当前的请求方法可以使用 <a class="reference internal" href="api.html#flask.Request.method" title="flask.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code></a> 属性. 要访问表单数据(在 <code class="docutils literal notranslate"><span class="pre">POST</span></code> 或 <code class="docutils literal notranslate"><span class="pre">PUT</span></code> 请求中传输的数据), 您可以使用 <code class="xref py py-attr docutils literal notranslate"><span class="pre">form</span></code> 属性. 以下是上述两个属性的完整示例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="s1">&#39;GET&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">valid_login</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">],</span>
                       <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s1">&#39;password&#39;</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">log_the_user_in</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="s1">&#39;Invalid username/password&#39;</span>
    <span class="c1"># the code below is executed if the request method</span>
    <span class="c1"># was GET or the credentials were invalid</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;login.html&#39;</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">)</span>
</pre></div>
</div>
<p>如果 <code class="docutils literal notranslate"><span class="pre">form</span></code> 属性中不存在键, 会发生什么？在这种情况下, 会引发一个特殊的 <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(在 Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>. 您可以像标准一样捕获它 <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(在 Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> 但是如果不这样做, 则会显示HTTP 400 Bad Request错误页面. 因此, 对于许多情况, 您不必处理该问题.</p>
<p>要访问URL中提交的参数(<code class="docutils literal notranslate"><span class="pre">?key=value</span></code>), 您可以使用 <code class="xref py py-attr docutils literal notranslate"><span class="pre">args</span></code> 属性:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">searchword</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>我们建议使用 <cite>get</cite> 或通过捕获 <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(在 Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> 访问URL参数, 因为用户可能会更改URL并向其显示400个错误的请求页面, 在这种情况下用户不友好.</p>
<p>有关请求对象的方法和属性的完整列表, 请转到 <a class="reference internal" href="api.html#flask.Request" title="flask.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 文档.</p>
</div>
<div class="section" id="file-uploads">
<h3>文件上传<a class="headerlink" href="#file-uploads" title="永久链接至标题">¶</a></h3>
<p>您可以轻松地使用Flask处理上传的文件. 只要确保不要忘记在HTML表单上设置  <code class="docutils literal notranslate"><span class="pre">enctype=&quot;multipart/form-data&quot;</span></code> 属性, 否则浏览器根本不会传输你的文件.</p>
<p>上载的文件存储在内存中或文件系统上的临时位置. 您可以通过查看请求对象上的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">files</span></code> 属性来访问这些文件. 每个上传的文件都存储在该字典中. 它的行为就像一个标准的Python <code class="xref py py-class docutils literal notranslate"><span class="pre">file</span></code> 对象, 但它也有一个 <a class="reference external" href="https://werkzeug.palletsprojects.com/en/0.15.x/datastructures/#werkzeug.datastructures.FileStorage.save" title="(在 Werkzeug v0.15.x)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 方法, 它允许你将该文件存储在服务器的文件系统上. 这是一个简单的例子, 说明它是如何工作的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/upload&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">upload_file</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;the_file&#39;</span><span class="p">]</span>
        <span class="n">f</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;/var/www/uploads/uploaded_file.txt&#39;</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>如果要在将文件上载到应用程序之前了解文件在客户端上的命名方式, 可以访问 <a class="reference external" href="https://werkzeug.palletsprojects.com/en/0.15.x/datastructures/#werkzeug.datastructures.FileStorage.filename" title="(在 Werkzeug v0.15.x)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">filename</span></code></a> 属性. 但请记住, 这个价值可以伪造, 所以永远不要相信这个价值. 如果要使用客户端的文件名将文件存储在服务器上, 请通过Werkzeug为您提供的 <a class="reference external" href="https://werkzeug.palletsprojects.com/en/0.15.x/utils/#werkzeug.utils.secure_filename" title="(在 Werkzeug v0.15.x)"><code class="xref py py-func docutils literal notranslate"><span class="pre">secure_filename()</span></code></a> 函数传递:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>
<span class="kn">from</span> <span class="nn">werkzeug.utils</span> <span class="k">import</span> <span class="n">secure_filename</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/upload&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">upload_file</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;the_file&#39;</span><span class="p">]</span>
        <span class="n">f</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;/var/www/uploads/&#39;</span> <span class="o">+</span> <span class="n">secure_filename</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>有关更好的示例, 请查看 <span class="xref std std-ref">uploaded-files</span> 模式.</p>
</div>
<div class="section" id="cookies">
<h3>Cookies<a class="headerlink" href="#cookies" title="永久链接至标题">¶</a></h3>
<p>要访问cookie, 您可以使用 <a class="reference internal" href="api.html#flask.Request.cookies" title="flask.Request.cookies"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cookies</span></code></a> 属性. 要设置cookie, 您可以使用响应对象的 <a class="reference internal" href="api.html#flask.Response.set_cookie" title="flask.Response.set_cookie"><code class="xref py py-attr docutils literal notranslate"><span class="pre">set_cookie</span></code></a> 方法. 请求对象的 <a class="reference internal" href="api.html#flask.Request.cookies" title="flask.Request.cookies"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cookies</span></code></a> 属性是一个包含客户端传输的所有cookie的字典. 如果你想使用会话, 不要直接使用cookie, 而是在Flask中使用 <a class="reference internal" href="#sessions"><span class="std std-ref">Sessions</span></a>, 为你添加一些基于cookie的安全性.</p>
<p>读饼干:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">cookies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">)</span>
    <span class="c1"># use cookies.get(key) instead of cookies[key] to not get a</span>
    <span class="c1"># KeyError if the cookie is missing.</span>
</pre></div>
</div>
<p>存储cookie:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">make_response</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">make_response</span><span class="p">(</span><span class="n">render_template</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
    <span class="n">resp</span><span class="o">.</span><span class="n">set_cookie</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="s1">&#39;the username&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">resp</span>
</pre></div>
</div>
<p>请注意, cookie是在响应对象上设置的. 由于您通常只是从视图函数返回字符串, Flask会将它们转换为响应对象. 如果您明确要这样做, 可以使用 <a class="reference internal" href="api.html#flask.make_response" title="flask.make_response"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_response()</span></code></a> 函数然后修改它.</p>
<p>有时您可能希望在响应对象尚不存在的位置设置cookie. 这可以通过使用 <a class="reference internal" href="patterns/deferredcallbacks.html#deferred-callbacks"><span class="std std-ref">延期请求回调</span></a> 模式来实现.</p>
<p>为此, 请参阅 <a class="reference internal" href="#about-responses"><span class="std std-ref">关于回应</span></a>.</p>
</div>
</div>
<div class="section" id="redirects-and-errors">
<h2>重定向和错误<a class="headerlink" href="#redirects-and-errors" title="永久链接至标题">¶</a></h2>
<p>要将用户重定向到另一个端点, 请使用 <a class="reference internal" href="api.html#flask.redirect" title="flask.redirect"><code class="xref py py-func docutils literal notranslate"><span class="pre">redirect()</span></code></a> 函数;要使用错误代码提前中止请求, 请使用 <a class="reference internal" href="api.html#flask.abort" title="flask.abort"><code class="xref py py-func docutils literal notranslate"><span class="pre">abort()</span></code></a> 函数:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">abort</span><span class="p">,</span> <span class="n">redirect</span><span class="p">,</span> <span class="n">url_for</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;login&#39;</span><span class="p">))</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="n">abort</span><span class="p">(</span><span class="mi">401</span><span class="p">)</span>
    <span class="n">this_is_never_executed</span><span class="p">()</span>
</pre></div>
</div>
<p>这是一个相当无意义的例子, 因为用户将从索引重定向到他们无法访问的页面(401表示访问被拒绝), 但它显示了它的工作原理.</p>
<p>默认情况下, 会为每个错误代码显示黑白错误页面. 如果要自定义错误页面, 可以使用 <a class="reference internal" href="api.html#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">errorhandler()</span></code></a> 装饰器:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">render_template</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">page_not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;page_not_found.html&#39;</span><span class="p">),</span> <span class="mi">404</span>
</pre></div>
</div>
<p>注意 <a class="reference internal" href="api.html#flask.render_template" title="flask.render_template"><code class="xref py py-func docutils literal notranslate"><span class="pre">render_template()</span></code></a> 之后的 <code class="docutils literal notranslate"><span class="pre">404</span></code>. 这告诉Flask该页面的状态代码应为404, 这意味着找不到. 默认情况下, 假定为200, 转换为: 一切顺利.</p>
<p>有关详细信息, 请参阅 <a class="reference internal" href="errorhandling.html#error-handlers"><span class="std std-ref">Error handlers</span></a> .</p>
</div>
<div class="section" id="about-responses">
<span id="id7"></span><h2>关于回应<a class="headerlink" href="#about-responses" title="永久链接至标题">¶</a></h2>
<p>视图函数的返回值会自动转换为响应对象. 如果返回值是一个字符串, 它将转换为一个响应对象, 其中字符串作为响应体, 一个 <code class="docutils literal notranslate"><span class="pre">200</span> <span class="pre">OK</span></code> 状态代码和一个 <em class="mimetype">text/html</em> mimetype. Flask应用于将返回值转换为响应对象的逻辑如下:</p>
<ol class="arabic simple">
<li><p>如果返回了正确类型的响应对象, 则直接从视图返回.</p></li>
<li><p>如果是字符串, 则使用该数据和默认参数创建响应对象.</p></li>
<li><p>如果返回元组, 则元组中的项可以提供额外信息. 这样的元组必须采用 <code class="docutils literal notranslate"><span class="pre">(response,</span> <span class="pre">status,</span> <span class="pre">headers)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">(response,</span> <span class="pre">headers)</span></code> 的形式, 其中至少有一个项必须在元组中. <code class="docutils literal notranslate"><span class="pre">status</span></code> 值将覆盖状态代码, <code class="docutils literal notranslate"><span class="pre">headers</span></code> 可以是附加标题值的列表或字典.</p></li>
<li><p>如果这些都不起作用, Flask将假定返回值是一个有效的WSGI应用程序并将其转换为响应对象.</p></li>
</ol>
<p>如果要在视图中获取生成的响应对象, 可以使用 <a class="reference internal" href="api.html#flask.make_response" title="flask.make_response"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_response()</span></code></a> 函数.</p>
<p>想象一下, 你有这样的观点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;error.html&#39;</span><span class="p">),</span> <span class="mi">404</span>
</pre></div>
</div>
<p>你只需要使用 <a class="reference internal" href="api.html#flask.make_response" title="flask.make_response"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_response()</span></code></a> 包装返回表达式并获取响应对象来修改它, 然后返回它:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">make_response</span><span class="p">(</span><span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;error.html&#39;</span><span class="p">),</span> <span class="mi">404</span><span class="p">)</span>
    <span class="n">resp</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s1">&#39;X-Something&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;A value&#39;</span>
    <span class="k">return</span> <span class="n">resp</span>
</pre></div>
</div>
</div>
<div class="section" id="sessions">
<span id="id8"></span><h2>Sessions<a class="headerlink" href="#sessions" title="永久链接至标题">¶</a></h2>
<p>除了请求对象之外, 还有一个名为 <a class="reference internal" href="api.html#flask.session" title="flask.session"><code class="xref py py-class docutils literal notranslate"><span class="pre">session</span></code></a> 的第二个对象, 它允许您将特定于用户的信息从一个请求存储到下一个请求. 这是在cookie的基础上实现的, 并以加密方式对cookie进行签名. 这意味着用户可以查看cookie的内容但不能修改它, 除非他们知道用于签名的密钥.</p>
<p>要使用会话, 您必须设置密钥. 以下是会议的工作方式:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">redirect</span><span class="p">,</span> <span class="n">url_for</span><span class="p">,</span> <span class="n">escape</span><span class="p">,</span> <span class="n">request</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># Set the secret key to some random bytes. Keep this really secret!</span>
<span class="n">app</span><span class="o">.</span><span class="n">secret_key</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;_5#y2L&quot;F4Q8z</span><span class="se">\n\xec</span><span class="s1">]/&#39;</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">if</span> <span class="s1">&#39;username&#39;</span> <span class="ow">in</span> <span class="n">session</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;Logged in as </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">escape</span><span class="p">(</span><span class="n">session</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="s1">&#39;You are not logged in&#39;</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span><span class="p">:</span>
        <span class="n">session</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">        &lt;form method=&quot;post&quot;&gt;</span>
<span class="s1">            &lt;p&gt;&lt;input type=text name=username&gt;</span>
<span class="s1">            &lt;p&gt;&lt;input type=submit value=Login&gt;</span>
<span class="s1">        &lt;/form&gt;</span>
<span class="s1">    &#39;&#39;&#39;</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/logout&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logout</span><span class="p">():</span>
    <span class="c1"># remove the username from the session if it&#39;s there</span>
    <span class="n">session</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>如果你没有使用模板引擎(如本例所示), 这里提到的 <a class="reference internal" href="api.html#flask.escape" title="flask.escape"><code class="xref py py-func docutils literal notranslate"><span class="pre">escape()</span></code></a> 会为你逃避.</p>
<div class="admonition-how-to-generate-good-secret-keys admonition">
<p class="admonition-title">如何生成好的密钥</p>
<p>密钥应尽可能随机. 您的操作系统可以基于加密随机生成器生成相当随机的数据. 使用以下命令快速生成以下值 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Flask.secret_key</span></code> (或 <a class="reference internal" href="config.html#SECRET_KEY" title="SECRET_KEY"><code class="xref py py-data docutils literal notranslate"><span class="pre">SECRET_KEY</span></code></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ python -c &#39;import os; print(os.urandom(16))&#39;
b&#39;_5#y2L&quot;F4Q8z\n\xec]/&#39;
</pre></div>
</div>
</div>
<p>关于基于cookie的会话的注释:Flask将获取您放入会话对象的值并将它们序列化为cookie. 如果您发现某些值不会在请求中保留, 则确实启用了Cookie, 并且您没有收到明确的错误消息, 请检查页面响应中的Cookie大小与Web浏览器支持的大小相比较.</p>
<p>除了默认的基于客户端的会话, 如果你想在服务器端处理会话, 有几个Flask扩展支持这个.</p>
</div>
<div class="section" id="message-flashing">
<h2>消息闪烁<a class="headerlink" href="#message-flashing" title="永久链接至标题">¶</a></h2>
<p>良好的应用程序和用户界面都是关于反馈的. 如果用户没有得到足够的反馈, 他们可能最终会厌恶应用程序.  Flask提供了一种使用闪烁系统向用户提供反馈的简单方法. 闪存系统基本上可以在请求结束时记录消息, 并在下一个(也就是下一个)请求中访问它. 这通常与布局模板结合使用以显示消息.</p>
<p>要刷新消息, 请使用 <a class="reference internal" href="api.html#flask.flash" title="flask.flash"><code class="xref py py-func docutils literal notranslate"><span class="pre">flash()</span></code></a> 方法来获取可以使用的消息 <a class="reference internal" href="api.html#flask.get_flashed_messages" title="flask.get_flashed_messages"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_flashed_messages()</span></code></a>, 它也可以在模板中使用. 查看 <a class="reference internal" href="patterns/flashing.html#message-flashing-pattern"><span class="std std-ref">消息闪烁</span></a> 获取完整示例.</p>
</div>
<div class="section" id="logging">
<h2>记录<a class="headerlink" href="#logging" title="永久链接至标题">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">0.3 新版功能.</span></p>
</div>
<details class="changelog">
<summary>Changelog</summary></details><p>有时您可能处理的数据应该是正确的, 但事实并非如此. 例如, 您可能有一些客户端代码向服务器发送HTTP请求, 但显然格式不正确. 这可能是由用户篡改数据或客户端代码失败引起的. 在大多数情况下, 在这种情况下可以用 <code class="docutils literal notranslate"><span class="pre">400</span> <span class="pre">Bad</span> <span class="pre">Request</span></code> 回复, 但有时这样做不行, 代码必须继续工作.</p>
<p>您可能仍想记录发生了可疑的事情. 这是伐木工人派上用场的地方. 从Flask 0.3开始, 预先配置了一个记录器供您使用.</p>
<p>以下是一些示例日志调用:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;A value for debugging&#39;</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;A warning occurred (</span><span class="si">%d</span><span class="s1"> apples)&#39;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;An error occurred&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>附 <a class="reference internal" href="api.html#flask.Flask.logger" title="flask.Flask.logger"><code class="xref py py-attr docutils literal notranslate"><span class="pre">logger</span></code></a> 是一个标准的日志记录:class:<cite>~logging.Logger</cite>, 所以转到官方的 <a class="reference external" href="https://docs.python.org/library/logging.html">日志记录文档</a> 了解更多信息.</p>
<p>阅读更多内容 <a class="reference internal" href="errorhandling.html#application-errors"><span class="std std-ref">应用程序错误</span></a>.</p>
</div>
<div class="section" id="hooking-in-wsgi-middlewares">
<h2>挂钩WSGI中间件<a class="headerlink" href="#hooking-in-wsgi-middlewares" title="永久链接至标题">¶</a></h2>
<p>如果要将WSGI中间件添加到应用程序, 可以包装内部WSGI应用程序. 例如, 如果你想使用Werkzeug包中的一个中间件来处理lighttpd中的bug, 你可以这样做:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">werkzeug.contrib.fixers</span> <span class="k">import</span> <span class="n">LighttpdCGIRootFix</span>
<span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span> <span class="o">=</span> <span class="n">LighttpdCGIRootFix</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="using-flask-extensions">
<h2>使用Flask扩展<a class="headerlink" href="#using-flask-extensions" title="永久链接至标题">¶</a></h2>
<p>扩展程序是帮助您完成常见任务的程序包. 例如, Flask-SQLAlchemy 提供 SQLAlchemy 支持, 使其易于与 Flask 一起使用.</p>
<p>有关Flask扩展的更多信息, 请查看 <a class="reference internal" href="extensions.html#extensions"><span class="std std-ref">扩展</span></a>.</p>
</div>
<div class="section" id="deploying-to-a-web-server">
<h2>部署到Web服务器<a class="headerlink" href="#deploying-to-a-web-server" title="永久链接至标题">¶</a></h2>
<p>准备部署新的Flask应用了吗？转至 <a class="reference internal" href="deploying/index.html#deployment"><span class="std std-ref">部署选项</span></a>.</p>
</div>
</div>


          </div>
        </div>
      </div>
  <span id="sidebar-top"></span>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  
    
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/flask-logo-sidebar.png" alt="Logo"/>
            </a></p>
  

  <h3>Contents</h3>
  <ul>
<li><a class="reference internal" href="#">快速开始</a><ul>
<li><a class="reference internal" href="#a-minimal-application">最小的应用程序</a></li>
<li><a class="reference internal" href="#what-to-do-if-the-server-does-not-start">如果服务器未启动该怎么办</a><ul>
<li><a class="reference internal" href="#old-version-of-flask">旧版 Flask</a></li>
<li><a class="reference internal" href="#invalid-import-name">导入名称无效</a></li>
</ul>
</li>
<li><a class="reference internal" href="#debug-mode">调试模式</a></li>
<li><a class="reference internal" href="#routing">路由</a><ul>
<li><a class="reference internal" href="#variable-rules">变量规则</a></li>
<li><a class="reference internal" href="#unique-urls-redirection-behavior">唯一的URL/重定向行为</a></li>
<li><a class="reference internal" href="#url-building">URL构建</a></li>
<li><a class="reference internal" href="#http-methods">HTTP方法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#static-files">静态文件</a></li>
<li><a class="reference internal" href="#rendering-templates">渲染模板</a></li>
<li><a class="reference internal" href="#accessing-request-data">访问请求数据</a><ul>
<li><a class="reference internal" href="#context-locals">上下文本地</a></li>
<li><a class="reference internal" href="#the-request-object">请求对象</a></li>
<li><a class="reference internal" href="#file-uploads">文件上传</a></li>
<li><a class="reference internal" href="#cookies">Cookies</a></li>
</ul>
</li>
<li><a class="reference internal" href="#redirects-and-errors">重定向和错误</a></li>
<li><a class="reference internal" href="#about-responses">关于回应</a></li>
<li><a class="reference internal" href="#sessions">Sessions</a></li>
<li><a class="reference internal" href="#message-flashing">消息闪烁</a></li>
<li><a class="reference internal" href="#logging">记录</a></li>
<li><a class="reference internal" href="#hooking-in-wsgi-middlewares">挂钩WSGI中间件</a></li>
<li><a class="reference internal" href="#using-flask-extensions">使用Flask扩展</a></li>
<li><a class="reference internal" href="#deploying-to-a-web-server">部署到Web服务器</a></li>
</ul>
</li>
</ul>
<h3>Navigation</h3>
<ul>
  <li><a href="index.html">Overview</a>
    <ul>
          <li>Previous: <a href="installation.html" title="上一章">安装</a>
          <li>Next: <a href="tutorial/index.html" title="下一章">教程</a>
    </ul>
  </li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2010 Pallets Team.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0+/86bf9dca 创建。
    </div>

  </body>
</html>